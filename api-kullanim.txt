Seninle bir sistem tasarlamak istiyorum, bu sistem bir desktop app olarak tasarlanacak.
Proğramlama dili olarak python kullanılacak ve diğer yazılım paketleri python ekosisteminden olacak.
Amaç şu bir bahis uygulması geliştireceğiz aşağıda detayları var :
bir api hizmeti veren siteden api anahtarı ile, sezona dayalı lig id leri, takım id leri, ve oyuncu id leri çekilecek,
bahis firmasının bahis oranları günlük fiktstür olarak çekilecek,geriye dönük (1 yıl olabilir) günlük ve gelecek 1 hafta olarak çekilecek.
maç verileri,headtohead,takım istatistikleri(son 10 maç vs.),maç kadroları,maç bilgileri,maç sonuçları çekilecek,anlık maç bilgileri çekilecek(takip edilen yada fikstürün tamamı)
Bunları neden çekeceğiz ? web sitesinin sağlamış olduğu tüm hizmetleri yerelde depolayıp off line amaçlar için kullanabilmek,online amaçlar içinse anlık takip.
peki tüm bu işlemler ne işimize yarayacak ? bir deepqlearning ajan ve ortamı oluşturulacak, bu ajan bir insanın iddaa bayinde yada online bahis sitelerinde ki aksiyonlarını taklit edecek.
Örneğin : bir maç için kullanıcı nasıl bahis yapar ? bahis oranları üzerinden mi analiz yapar ? yada maç ın tarafları olan takımların istatistik ve kadro yapısını mı analiz eder ?
yada her ikisini de kullanarak bahis oranları ile istatistikleri birlikte mi kullanır ? (burada bahis firmaları manipülasyon yapabilir). tüm bu aksiyonları bir env. olarak tasarlamak ve burada stateler
üzerinden ajanı eğitmek,ajan iki farklı şekilde oluşturulabilir canlı bahis yani oynan maçları anlık olarak takip ederek ya istatistik üzerinden yada bahis üzerinden yada hibrit bir şekilde her ikisini de 
kullanarak maçın oynanış anındaki gol vs. durumlarına göre bahis yapabilir, diğer bir durum ise önceden kombine,sistem yada tekli maç şeklinde kupon hazırlayıp maç saatlerine göre kupon takibi yaparak
kendini eğitebilir, bu durumda geçmiş maçlar üzerinden kendini eğitip daha sonrasında kendini canlıya alıp gelecek maçlara bahis yapıp app tarafından sağlanan bilgiler ile kendini sürekli deneyebilir sürekli eğitebilir
sürekli kazanç kayıp durumuna göre kendini fine tunning edebilir,bu yönergelere göre aşağıdaki api kullanım bilgilerine göre bir veritabanı sistemi tasarla mimari oluştur.


--------------------------------------------------------------------------------
Databaseyapısı-basicplan
Aşağıda, sadece 3 tablo ile işinizi görecek biçimde kurguladığımız veri yapısının daha detaylı bir anlatımını bulacaksınız. Ana hedefleriniz şöyle:
1.
Maçlar ve takımlar (ülke, lig, sezon, skorlar, form vb.)
2.
Günlük bahis bülteni (oranlar, bahis türleri, bookmaker bilgisi vb.)
3.
Oyuncu bilgisi (sezon istatistikleri, sakatlık/eksik durumu, form, vb.)
Bu üç tablo bir yandan veri kaynaklarınızı (API) basitçe kapsar, diğer yandan AI/makine öğrenimi modellerine rahat veri besler. Ayrıca sadece üç tablo olduğundan veri yönetimi de çok karmaşık hale gelmez. Yine de tablo başına koyacağınız sütunların derinliği artabilir.
1) MATCHES_MASTER
Amaç
●
Tüm fikstür verisini (ülke, lig, sezon, takım) tek tabloda toplamak.
●
Hem geçmiş hem de gelecek maç bilgileri, puan durumu ve takımların form bilgisi gibi özet verileri içerir.
●
Modelleriniz bu tablodan geçmiş performansı okurken, gelecek maçlar için tahmin çıkarabilir.
Tablonun Mantığı
Birçok yerde normalizasyon gereği bu veriler (ülke, lig, takım vb.) farklı tablolar olarak saklanır. Fakat sizin “3 tablo” sınırınız nedeniyle her şeyi tek tabloda geniş sütunlar şeklinde tutacağız. Maç bazında her satır, maçla ilgili tüm bilgiyi barındıracak.
Önerilen Kolonlar
1.
match_id (PK):
●
Maç kimliği (API’nin fixture_id’si).
●
Tablonun birincil anahtarı.
1.
date:
●
Maçın oynanma tarihi ve saati.
●
Hem geçmiş hem de gelecek maçlar için kullanılır.
●
Zaman bazlı sorgular için indekslenmesi faydalı olabilir.
1.
country_name ve country_code:
●
Maçın ait olduğu ülke bilgisi.
●
Bazı ligler çok ülke kapsıyor (örneğin UEFA müsabakaları), yine de temel “ülke” bilgisini tutmak ileride filtrelerken işinize yarar.
1.
league_id, league_name, season:
●
Ligle ilgili temel bilgiler.
●
Sezon: 2023, 2024 vb.
●
Tek tabloda bulundurduğumuzdan, sezon değişse de yeni kayıtlar eklenir.
1.
home_team_id, home_team_name
2.
away_team_id, away_team_name
●
Evsahibi / deplasman takım kimlikleri ve adları.
●
AI modeli hangi takım kimdir diye bakarken bunlar yeterli olacak.
●
Takım formu veya puan tablosu gibi detayları alt sütunlarda tutacağız.
1.
status:
●
Maçın durumu (Not Started, Live, Finished, Postponed vb.)
●
Geçmiş maçlardaki satırlar "Finished" olacak, gelecektekiler "Not Started" vb.
1.
score_home, score_away:
●
Maç bittiğinde tam skor.
●
Gelecek maçlar için bu kolonlar NULL (veya -1) kalabilir.
1.
halftime_score_home, halftime_score_away (Opsiyonel):
●
Daha detaylı analiz istiyorsanız ilk yarı skorunu da tutabilirsiniz.
1.
form_snapshot_home, form_snapshot_away:
●
Takımların maç öncesi form durumu, puan tablosu, son 5 maç “WDL” gibi.
●
Öneri: Tek sütunda JSON saklanabilir. Örneğin:
●
{
●
"points": 45,
●
"rank": 2,
●
"last5": "WWLDW",
●
"goals_scored_per_match": 2.1,
●
"goals_conceded_per_match": 0.9
●
}
●
Bu form/mertik verisini API’den “takım istatistikleri” endpoint’inden çekip, maç kaydı oluştururken snapshot halinde işleyebilirsiniz.
1.
additional_info (Opsiyonel JSON alanı):
●
Hakem, stadyum, hava durumu, extra veriler. Tek bir JSON olarak saklanabilir.
Kullanım Senaryosu:
●
AI modeli: Geçmiş maçların skorlarını, takımların form verilerini inceleyip bir “takım güç puanı” öğrenir.
●
Tahmin oluşturma: Gelecek maç satırları (status=‘NS’) için form_snapshot alanlarını da modele ekleyerek skora dair tahmin üretirsiniz.
●
Raporlama: Bir lig + sezon + tarih aralığı + takım filtreleriyle veriyi çekip bülten tarzı listeleme yapabilirsiniz.
2) DAILY_BETTING_LINES
Amaç
●
O gün (veya her gün) sunulan bahis bülteni, bahis türleri ve oranlar burada tutulur.
●
Aynı match_id ile MATCHES_MASTER’a bağlanırsınız.
●
Gün içinde oran değişikliğini kaydetmek isterseniz update_timestamp gibi bir alan ekleyip her sürümü saklayabilirsiniz.
Tablonun Mantığı
Tüm bahis satırlarını ve oranlarını tek tabloda depolayacağız. Normalde, “bahis türleri” (bet_type), “bookmaker” vs. için ayrı tablolar yapılır. Fakat bizde 3 tablo sınırı var, bu yüzden her satırda hangi bahsi, hangi bookmaker’dan, hangi oranda aldığınızı tek kayıtta tutacağız.
Önerilen Kolonlar
1.
betting_id (PK, otomatik):
●
Tablo için benzersiz kimlik.
1.
match_id:
●
MATCHES_MASTER.match_id ile FK ilişkisi.
●
Hangi maçın oranı olduğunun tespiti.
1.
date_of_bulletin:
●
Bu bahis bülteni hangi günün verisidir?
●
Genellikle maçın oynanacağı gün veya bir gün öncesi vb.
1.
bet_type:
●
Örneğin “Full Time Result (1X2)”, “Over/Under 2.5”, “Both Teams to Score” gibi.
●
Farklı bet türlerine göre alt sütunlar da gerekebilir.
1.
odds_home, odds_draw, odds_away (Varsa)
●
Eğer bet_type = “Full Time Result” için 1 / X / 2 formatında.
●
Over/Under tipinde “odds_over”, “odds_under” gibi kolonlar da eklenebilir.
●
Çok çeşitli bet türleri varsa, hepsini kapsayan kolonlar yapmak zor olabilir.
●
Öneri: Bir “odds_json” sütunu ile tüm varyasyonu JSON’da saklayın.
1.
Örnek JSON formatı:
2.
{
3.
"1": 1.85,
4.
"X": 3.50,
5.
"2": 4.20,
6.
"OUline": 2.5,
7.
"Over": 2.00,
8.
"Under": 1.75
9.
}
10.
bookmaker_name (veya “bookmaker_id”):
●
Hangi bahis firması ya da hangi kaynak.
●
Bir tablo yerine tek sütunda tutuyoruz (3 tablo sınırından dolayı).
1.
live_or_prematch:
●
“live” veya “prematch” bilgisi.
1.
update_timestamp:
●
Oranların güncellendiği zaman.
●
Eğer günde bir kez çekiyorsanız, gene de bir timestamp olsun.
1.
is_suspended (opsiyonel):
●
API’de bazen bazı bahis marketleri “suspended” olabiliyor. Bunu da burada tutabilirsiniz.
Kullanım Senaryosu:
●
Günlük cron job veya manuel işlemle tüm maçların bahis oranlarını çekip bu tabloya ekliyorsunuz.
●
AI modeli bu tabloyu MATCHES_MASTER ile join’leyip “Bu maç, ev sahibinin formu X, oran 1.85 => model tahmini: Ev sahibi kazanır” diye analiz yapar.
●
Tarih bazlı: “Belirli bir güne (veya date range) ait tüm maçların oranlarını getir” şeklinde sorgulayıp bahis bülteni oluşturabilirsiniz.
●
Zaman serisi: Oranların gün içinde nasıl değiştiğini takip etmek istiyorsanız, yeni sürümü ekleyerek update_timestamp'e göre sıralayabilirsiniz.
3) PLAYERS_DB
Amaç
●
Oyunculara dair tüm temel bilgi (isim, takım, pozisyon, vs.) + mevsimsel veya güncel istatistiksel veri + sakat/eksik durum gibi.
●
Bu tabloyu basit tutacağız ancak “takım bazlı, sezon bazlı, form bazlı” verileri tek tabloda wide formatta saklayacağız.
●
Gerektiğinde team_id üzerinden MATCHES_MASTER’daki home/away takımla eşleştirme yapabilirsiniz.
Tablonun Mantığı
Normalde “player_season_stats”, “injuries” vs. gibi tablolar ayrı olur. Bizde 3 tablo kısıtı var, dolayısıyla tek bir “oyuncu master” tablosuna gömüyoruz. JSON alanlarını kullanmak en mantıklı yol.
Önerilen Kolonlar
1.
player_id (PK)
●
API’nin player_id’si.
1.
player_name
●
Ad + soyad, veya firstname/lastname gibi alt kolonlar da eklenebilir ama basit tutuyoruz.
1.
team_id, team_name
●
Oyuncunun güncel takımı.
●
Bu “team_id” MATCHES_MASTER’daki home_team_id veya away_team_id’ye denk gelir.
1.
position
●
“Goalkeeper”, “Defender”, “Midfielder”, “Attacker” vb.
1.
season_stats (JSON)
●
Geniş bir JSON, sezon bazında ortalama veya toplam istatistikleri tutar. Örnek:
●
{
●
"season": 2023,
●
"appearences": 20,
●
"goals": 5,
●
"assists": 3,
●
"rating_avg": 7.1,
●
"minutes_played": 1700
●
}
●
Farklı sezonlar için bir dizi de olabilir. Tek satırda tüm sezon bilgisi:
●
[
●
{ "season": 2022, "goals": 8, "rating": 7.0 },
●
{ "season": 2023, "goals": 5, "rating": 7.1 }
●
]
1.
availability_status
●
“fit”, “injured”, “suspended”, “questionable” vb.
1.
player_form (JSON)
●
Son 5 maç rating, gol vb. trendi.
●
Örnek:
●
{
●
"last5_ratings": [7.0, 6.5, 7.5, 6.0, 7.8],
●
"last5_goals": 3,
●
"last5_assists": 1
●
}
●
Modelleriniz “Bu oyuncunun formu yükselişte mi, düşüşte mi?” sorusuna buradan bakabilir.
1.
birthdate, age (opsiyonel)
●
Yaş bazlı analiz gerekebilir. Makine öğrenimi için konabilir.
Kullanım Senaryosu:
●
Bir cron job, API’den her hafta oyuncu istatistiklerini günceller.
●
AI modeli; “Takımın en golcü oyuncuları sakat mı? Son 5 maç formu nedir?” gibi bilgiyi PLAYERS_DB üzerinden okur.
●
Maç gününde “home takımın kilit forveti sakat => gol atma ihtimali düşer => modelde weighting değişiyor”.
Tablolar Arası İlişki ve Sorgulama Örnekleri
İlişki:
1.
MATCHES_MASTER ↔ DAILY_BETTING_LINES:
●
Ortak anahtar: match_id.
●
“Maça dair skor, takımlar, form durumları + bu maçın oranları”
1.
MATCHES_MASTER ↔ PLAYERS_DB:
●
Ortak anahtar: team_id. (Maçta home_team_id veya away_team_id, oyuncunun team_idsine denk gelir).
●
“Maçta oynayacak oyuncuların form durumu, sakatlık durumu, rating vb.”
Sorgu Örneği 1:
“Gelecek 7 gün içinde oynanacak (status=NS) maçların oranlarını getir ve home takımın en iyi forveti sakat mı?”
●
MATCHES_MASTER (status=NS, date<today+7)
●
JOIN DAILY_BETTING_LINES ON match_id
●
JOIN PLAYERS_DB ON MATCHES_MASTER.home_team_id = PLAYERS_DB.team_id AND PLAYERS_DB.availability_status != ‘fit’ AND PLAYERS_DB.position=‘Attacker’
Sorgu Örneği 2:
“Son 10 maçta en çok gol atan takımın ortalama oranları neydi?”
●
MATCHES_MASTER (last 10 matches per team) => sum(goals_home) / 10
●
JOIN DAILY_BETTING_LINES => average(odds_home)
Akış (Data Flow) Örneği
1.
Günlük / Haftalık Cron:
●
MATCHES_MASTER: API’den “fixtures” endpoint’ini çekerek o haftaki veya son 2 yılın maçlarını dolduruyorsunuz. (Yeni maç geldikçe eklenecek, bitmiş maç skorları güncellenecek.) Form snapshot’ları da API’den “standings” ya da “teams/statistics” benzeri endpoint’lerle doldurabilirsiniz.
●
PLAYERS_DB: Oyuncu bazlı endpoint’ten tüm sezona dair temel istatistikleri JSON olarak alıp güncelleyebilirsiniz. Veya sakatlık endpoint’ini kontrol ederek “availability_status” set edebilirsiniz.
1.
Günlük Bülten:
●
DAILY_BETTING_LINES: O günün (veya yakın günlerin) tüm maçlarının bahis oranlarını “odds” endpoint’inden çekip bu tabloya yazarsınız. (Bir match_id için birden fazla bet_type satırı olabilir.)
●
İster iseniz oran değişikliğinde update_timestamp ile bir yeni satır ekleyebilirsiniz, veya satırı güncelleyebilirsiniz.
1.
Model Çalıştırma:
●
Model, MATCHES_MASTER’den her takımın form bilgisini, geometri bilgisini (gol farkları, galibiyet serisi vb.) alır.
●
DAILY_BETTING_LINES’den ilgili maçın güncel oranlarını alır.
●
PLAYERS_DB’den o takımın en önemli oyuncularının formu/sakatlık durumu vb. alır.
●
Tahminini üretir (örneğin, ev sahibi galibiyeti olasılığı %60).
1.
Sonuç:
●
Bu “3 tablo” yaklaşımı, veri entegrasyonunu basitleştirir.
●
Normalizasyonu minimal tuttuğunuz için sorgu tarafı kolay, ama tablolar büyüdükçe performans takibi gerekecektir.
Neden JSON Sütunlarını Öneriyoruz?
●
Çünkü “3 tablo” sınırlaması, normalde tablo bazında ayıracağınız detayları tek tablo içinde “esnek alanlar” olarak tutmayı gerektiriyor.
●
Avantaj: Yeni bir metrik (xG, top kesme, koşu mesafesi vb.) eklemek isterseniz tabloya kolonu eklemeden JSON’a koyabilirsiniz.
●
Dezavantaj: JSON içindeki verilere sorgu ve indeks oluşturmak ilişkisel veritabanlarında sınırlı veya karmaşık olabilir. Performans düşebilir.
Olası Genişletmeler ve İyileştirmeler
1.
Index Kullanımı:
●
match_id (PRIMARY KEY)
●
date için index
●
team_id (özellikle PLAYERS_DB’de) için index
●
bet_type + match_id (DAILY_BETTING_LINES) için composite index
1.
Versiyonlama:
●
Oranlar sıklıkla değişiyorsa “DAILY_BETTING_LINES” tablo satırlarını “insert” modunda tutup update_timestamp ile kaydedebilirsiniz.
●
MATCHES_MASTER’da skor veya statü değişimlerini “güncelleme” yerine “yeni sürüm ekleme” de mümkündür, ama tablo karmaşıklaşır.
1.
Performans:
●
3 tabloda da JSON alanları çok büyürse okuma yavaşlar.
●
Sık sorgulanan metriklere dair kolonlar açabilirsiniz (ör. “points_home_team_before_match” gibi).
1.
Data Cleansing:
●
API’den gelen verileri düzenli şekilde parse etmek önemli.
●
Maçlar iptal olursa, fixture_id değişirse tablo güncellemeleri vs.
1.
Veri Ambarı:
●
İleride sorgular/raporlar ağırlaşırsa, bu 3 tabloyu kaynak olarak kullanıp “boyutsal” bir veri ambarına veri aktarabilirsiniz.
Sonuç: 3 Tablo, Detaylı Biçimde
1.
MATCHES_MASTER
●
Amaç: Ülke, lig, sezon, tarih, skor, form snapshot, puan bilgisi vb. hepsi tek yerde
●
Anahtar: match_id
●
Önerilen Kolonlar: match_id, date, country_name, league_id, league_name, season, home_team_id, home_team_name, away_team_id, away_team_name, status, score_home, score_away, form_snapshot_home (JSON), form_snapshot_away (JSON), additional_info (JSON)...
1.
DAILY_BETTING_LINES
●
Amaç: Günlük bahis bülteni ve oranlar
●
Anahtar: betting_id, + (FK:match_id)
●
Önerilen Kolonlar: betting_id, match_id, date_of_bulletin, bet_type, odds_home, odds_draw, odds_away (veya odds_json), bookmaker_name, live_or_prematch, update_timestamp
1.
PLAYERS_DB
●
Amaç: Oyuncu bilgilerinin tamamı + sezon/maç istatistikleri + sakatlık/form durumu
●
Anahtar: player_id
●
Önerilen Kolonlar: player_id, player_name, team_id, team_name, position, availability_status, season_stats (JSON), player_form (JSON), birthdate, vb.
Bu tablo yapısıyla:
●
AI/makine öğrenimi için gerekli özet veriyi kolayca çekebilirsiniz (form durumu, skorlar, oranlar, oyuncu sakatlığı...).
●
Günlük güncellemeler (maç skorları, yeni oranlar, oyuncu sakatlıkları) her tabloya ilgili alanlarda eklenebilir veya güncellenebilir.
●
Sorgu: “Tek tabloda her şey” yaklaşımı kadar basit ama mantıklı bir şekilde ayrılmış olduğu için dayanaklı ve anlaşılır olur.
Bu şekilde “3 tablo” sınırında kalırken, yine de futbol verisini yeterince organize ve analiz edilebilir bir düzene oturtmuş oluyorsunuz. İleride gerekirse, bu tablo yapısının altına normalleştirilmiş ufak tablo katmanları ekleyebilir veya “JSON” alanlarını açıp ek tablolar oluşturabilirsiniz. Şu an için minimum tablo, maksimum işlev prensibiyle önerilerimiz bu şekildedir.

--------------------------------------------------------------------------------
Futbol Veri API'si: Detaylı Kılavuz
Detaylı API Briefing Dokümanı
Giriş:
Bu belge, sağlanan "Tüm notlar 20.12.2024" ve "tüm notlar bir arada" kaynaklarından derlenmiş, futbol verileri sağlayan çeşitli API uç noktalarını detaylı bir şekilde incelemektedir. Her bir uç noktanın amacı, özellikleri, kullanım senaryoları, parametreleri ve diğer uç noktalarla karşılaştırılması ele alınacaktır. Ayrıca, her uç nokta için örnek Python betikleri ve PyQt5 uygulamaları sunularak, verilerin nasıl çekileceği ve görüntüleneceği açıklanacaktır.
Genel API Bilgileri:
●
API Anahtarı: API'ye erişim için x-apisports-key başlığı kullanılmaktadır.
●
API Host: v3.football.api-sports.io adresi üzerinden erişilmektedir.
●
Güncellenme Sıklığı: Uç noktaların güncellenme sıklıkları farklılık göstermektedir. Genellikle canlı veriler daha sık güncellenirken, statik veriler daha az sıklıkla yenilenmektedir.
●
Rate Limit: Bazı uç noktalar için, aşırı sorgu yükünü önlemek için çağrı limitleri bulunmaktadır. Örneğin, bazı endpointler için günde 1, saatte 1, ya da dakikada 1 çağrı önerilmektedir.
Uç Noktaların İncelenmesi:
1. /odds/bets Endpoint (Maç Öncesi Bahis Türleri):
●
Amaç: Maç öncesi oranlar (pre-match odds) için mevcut bahis türlerini getirir.
●
Özellikler:
○
ID'ler, /odds endpointinde kullanılabilir.
○
/odds/live endpointi ile uyumlu değildir.
○
Haftada birkaç kez güncellenir.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
id: Bahis türünün kimliğini belirtir.
○
search: Bahis türü adı üzerinden arama yapar (en az 3 karakter).
2. /odds/bookmakers Endpoint (Bahis Şirketleri):
●
Amaç: Mevcut tüm bahisçilerin (bookmakers) listesini getirir.
●
Özellikler:
○
Bahisçi ID'leri, diğer oranlarla ilgili endpointlerde filtreleme için kullanılabilir.
○
Birkaç günde bir güncellenir.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
id: Belirli bir bahisçinin ID'sini belirtir.
○
search: Bahisçi adıyla arama yapar (en az 3 karakter).
3. /odds/mapping Endpoint (Maç ID ve Lig Bilgileri):
●
Amaç: Belirli bir tarihteki veya ligdeki maçların ID'lerini sağlar. Bu ID'ler, oranlar için kullanılan diğer uç noktalarla filtreleme için kullanılır.
●
Özellikler:
○
Lig ID'leri, sezon bilgileri, maç tarihleri ve son güncellenme zamanı gibi bilgiler içerir.
○
Günlük olarak güncellenir.
○
100 sonuç/sayfa olacak şekilde paginasyon (pagination) destekler.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
page: Sayfa numarası (pagination)
●
Karşılaştırma:
○
/odds/live: Canlı maçlar için dinamik oranlar sunar, 5-60 saniye güncelleme sıklığına sahiptir.
○
/odds/live/bets: Canlı bahis türlerini listeler, 60 saniye güncelleme sıklığına sahiptir.
○
/odds: Maç öncesi oranları listeler, 3 saatte bir güncellenir, 10 sonuç/sayfa paginasyon vardır.
○
/odds/mapping: Oranlar için kullanılabilir maç ID'lerini sağlar, günlük olarak güncellenir, 100 sonuç/sayfa paginasyon vardır.
4. /odds Endpoint (Maç Öncesi Oranlar):
●
Amaç: Belirli bir maç, lig veya tarihe göre maç öncesi oranları sağlar.
●
Özellikler:
○
Maçtan 1-14 gün öncesine kadar olan oranlar görüntülenebilir.
○
7 günlük geçmiş oranlar da mevcuttur.
○
Kullanıcılar bahis şirketi, bahis türü, lig veya tarih bazında filtreleme yapabilir.
○
Her 3 saatte bir güncellenir.
○
10 sonuç/sayfa paginasyon vardır.
●
Parametreler:
○
fixture: Maç ID'si
○
league: Lig ID'si
○
season: Sezon
○
date: Tarih (YYYY-MM-DD formatında)
○
timezone: Zaman dilimi
○
bookmaker: Bahis şirketi ID'si
○
bet: Bahis türü ID'si
○
page: Sayfa numarası (pagination)
●
Karşılaştırma:
○
/odds/live: Canlı maç oranları, dinamik güncellenir.
○
/odds/live/bets: Canlı bahis türleri listesi.
5. /odds/live Endpoint (Canlı Maç Oranları):
●
Amaç: Canlı maçlar için oranları ve bahis türlerini sağlar.
●
Özellikler:
○
Maç ilerledikçe oranlar dinamik olarak güncellenir.
○
Güncellenme sıklığı: 5-60 saniye arası.
●
Kullanım Alanları:
○
Canlı olarak devam eden maçlarda oranları ve bahis seçeneklerini görüntülemek.
○
Anlık olarak bahis oynayan kullanıcılar için güncel bilgi sağlamak.
6. /odds/live/bets Endpoint (Canlı Bahis Türleri):
●
Amaç: Mevcut tüm canlı bahis türlerini döndürür.
●
Özellikler:
○
Statik veri, belirli bir maç için oran bilgisi içermez.
○
Güncellenme sıklığı: 60 saniye.
●
Kullanım Alanları:
○
Kullanıcıların hangi bahis türlerinin desteklendiğini öğrenmesi.
○
Bahis türlerini filtrelemek için kullanılacak ID'lerin elde edilmesi.
7. Top Yellow Cards Endpoint (En Çok Sarı Kart Alan Oyuncular):
●
Amaç: Bir lig veya turnuvada en çok sarı kart gören oyuncuları döndürür.
●
Hesaplama Metodu:
1.
Sarı kart sayısına göre sıralama.
2.
Eşitlik halinde kırmızı kart sayısı dikkate alınır.
3.
Eşitlik devam ederse maç sayısı ve dakika süresi analiz edilir.
●
Çağrı Sıklığı: Günde bir kez önerilir.
8. Top Red Cards Endpoint (En Çok Kırmızı Kart Alan Oyuncular):
●
Amaç: Bir lig veya turnuvada en çok kırmızı kart gören oyuncuları döndürür.
●
Hesaplama Metodu:
1.
Kırmızı kart sayısına göre sıralama.
2.
Eşitlik halinde sarı kart sayısı dikkate alınır.
3.
Oyuncunun oynadığı süre ve maç sayısı da sıralamaya katkı sağlar.
●
Çağrı Sıklığı: Günde bir kez önerilir.
9. Top Assists Endpoint (En Çok Asist Yapan Oyuncular):
●
Amaç: Belirli bir lig veya kupa için bir sezondaki en fazla asist yapan ilk 20 oyuncuyu döndürür.
●
Kullanım Alanları:
○
Asist performansı analizi.
○
Takım planlaması.
○
Fantezi lig stratejileri.
10. Top Scorers Endpoint (En Çok Gol Atan Oyuncular):
●
Amaç: Belirli bir lig veya kupa için sezon bazında en iyi 20 golcüyü döndürür.
●
Kullanım Alanları:
○
Performans karşılaştırması.
○
Taktiksel planlama.
○
Fantezi lig stratejileri.
11. Players/Teams Endpoint (Oyuncu Takım ve Sezon Bilgileri):
●
Amaç: Bir oyuncunun kariyerindeki takımları ve bu takımlarda oynadığı sezonları listeler.
●
Kullanım Alanları:
○
Kariyer takibi.
○
Kapsamlı istatistikler.
○
Tarihsel analiz.
12. Statistics Endpoint (Oyuncu İstatistikleri):
●
Amaç: Oyuncuların profillerine ve istatistiklerine ulaşmak için kullanılır. Belirli bir sezon, takım ve ligdeki performans verilerini içerir.
●
Özellikler:
○
Oyuncunun transfer geçmişine göre birden fazla takım için bulunabilir.
○
Oyuncunun performansına göre hesaplanan bir "rating" (puanlama) değeri sağlar.
●
Kullanım Alanları:
○
Performans analizi.
○
Transfer verisi.
○
Rekabetçi analiz.
○
Takım analizi.
●
Arama: Oyuncu ID'si, takım ID'si, lig ID'si, sezon ve isme göre arama yapılabilir.
●
Rating Değeri: Oyuncunun performansını ölçen bir değerdir. Gol, asist, şut yüzdesi (hücum oyuncuları için) veya müdahale, top çalma, kurtarış yüzdesi gibi metrikler (savunma ve kaleciler için) kullanılır.
13. Profiles Endpoint (Oyuncu Profilleri):
●
Amaç: Futbol oyuncularının profilleriyle ilgili kapsamlı bilgi sağlar. Biyografi, fiziksel özellikler, pozisyonlar ve fotoğraflar içerir.
●
Özellikler:
○
Haftada birkaç kez güncellenir.
○
Haftada 1 çağrı önerilir.
○
Pagination (sayfalama) destekler.
●
Kullanım Alanları:
○
Oyuncu bilgisi görüntüleme.
○
Arama ve filtreleme.
○
Veritabanı güncelleme.
14. Seasons Endpoint (Oyuncu Sezon Bilgileri):
●
Amaç: Bir oyuncunun istatistiklerinin bulunduğu tüm sezonların listesini döner.
●
Özellikler: Günlük olarak güncellenir.
●
Kullanım Alanları:
○
Kariyer analizi (sezona göre).
○
Geçmiş performans karşılaştırmaları.
15. Predictions Endpoint (Maç Tahminleri):
●
Amaç: Belirli bir maç (fixture) için tahminleri getirir.
●
Özellikler:
○
İstatistiksel analiz, son maçlar, takım performansı, oyuncu verileri ve Poisson dağılımı gibi algoritmalarla oluşturulur.
○
Bahis oranları kullanılmaz.
●
Tahmin Türleri:
○
Match Winner (maç kazananı).
○
Win or Draw (kazanma veya berabere kalma).
○
Under/Over Goals (toplam gol tahminleri).
○
Goals Home / Away (ev sahibi/deplasman gol tahminleri).
○
Advice (tavsiye).
○
Yüzde dağılımları (ev sahibi, deplasman, beraberlik).
●
Güncellenme Sıklığı: Saatlik.
16. Injuries Endpoint (Sakatlık ve Cezalar):
●
Amaç: Maçlara katılamayan veya katılımı şüpheli olan oyuncuların listesini getirir.
●
Özellikler:
○
Missing Fixture: Oyuncu kesin olarak katılamıyor.
○
Questionable: Oyuncunun durumu belirsiz.
○
4 saatte bir güncellenir.
○
Günde 1 çağrı önerilir.
●
Parametreler:
○
league, season, fixture, team, player, date, ids, timezone
17. Lineups Endpoint (Maç Kadroları):
●
Amaç: Bir maçın (fixture) kadro bilgilerini listeler.
●
Özellikler:
○
Başlangıç 11'i, yedek oyuncular ve teknik direktör bilgileri içerir.
○
15 dakikada bir güncellenir.
●
Parametreler:
○
fixture, team
18. Events Endpoint (Maç Olayları):
●
Amaç: Belirli bir maça (fixture ID) ait tüm olayları getirir.
●
Olay Türleri:
○
Goal (Normal Gol, Kendi Kalesine Gol, Penaltı, Kaçırılan Penaltı)
○
Card (Sarı Kart, Kırmızı Kart)
○
Subst (Oyuncu Değişikliği)
○
Var (VAR Kararları)
●
Özellikler:
○
15 saniyede bir güncellenir.
●
Kullanım Alanları:
○
Maç sırasında veya sonrasında tüm önemli olayları görüntülemek.
○
Canlı maçların anlık takibini sağlamak.
●
Parametreler: fixture, team, player, type
19. Statistics Endpoint (Maç İstatistikleri):
●
Amaç: Belirli bir maça (fixture ID) ait detaylı istatistikleri getirir.
●
Özellikler:
○
Şutlar, paslar, fauller, kartlar vb. gibi tüm önemli istatistikleri içerir.
○
1 dakika aralıklarla güncellenir.
○
Canlı maçlar için dakikada 1 çağrı önerilir. Normal kullanım için günde 1 çağrı önerilir.
20. Fixtures Endpoint (Maç Programları):
●
Amaç: Bir ligin, takımın veya turnuvanın maç programlarını detaylı bir şekilde almanızı sağlar.
●
Özellikler:
○
Tarih, saat, statü ve skor bilgileri içerir.
○
Canlı maçları görüntüleme, geçmiş maç sonuçlarını çekme, lig ve sezon bazlı analizler yapma imkanı sunar.
●
Parametreler:
○
Lig, sezon, tarih aralığı, durum, takım, zaman dilimi gibi çeşitli filtreler kullanılabilir.
●
Batch Mantığı:
○
API, tek seferde en fazla 20 fixture ID isteğini destekler. Bu nedenle, büyük veri setleri için ID'ler 20'lik gruplara ayrılmalı ve her grup API'ye ayrı ayrı gönderilmelidir.
●
Progress Bar: Verilerin çekilmesi sırasında kullanıcıya işlem ilerlemesini göstermek için bir progress bar kullanılması önerilir.
21. H2H Endpoint (Takımlar Arası Karşılaşmalar):
●
Amaç: İki takımın geçmiş karşılaşmalarını getirir.
●
Özellikler:
○
Maç tarihleri, skorlar, lig bilgileri içerir.
●
Parametreler:
○
h2h: İki takımın ID'leri (ID-ID formatında).
○
date, league, season, last, next, from, to, status, venue, timezone gibi opsiyonel filtreler kullanılabilir.
22. Rounds Endpoint (Lig Turları):
●
Amaç: Belirli bir ligin veya kupanın mevcut sezonundaki turlar listesini almak için kullanılır.
●
Özellikler:
○
Fikstür verisi filtreleme için /fixtures endpointi ile birlikte kullanılabilir.
○
Mevcut tur bilgisini ve her turun başlangıç/bitiş tarihini almak için kullanılabilir.
●
Parametreler:
○
league, season, current, dates
23. Standings Endpoint (Puan Durumları):
●
Amaç: Tüm aktif liglerin puan durumlarını (standings) almak için kullanılır.
●
Özellikler:
○
Bir ligde birden fazla sıralama (grup aşaması, açılış, kapanış gibi) varsa bu veriler de döner.
○
Aktif sezon ve lig ID'leri kullanılarak standings endpoint'ine sorgular gönderilir.
24. Teams Countries Endpoint (Ülke Listeleri):
●
Amaç: teams endpoint'inde kullanılabilecek ülkelerin listesini döndürür.
●
Özellikler:
○
Ülke adı, ülke kodu (ISO Alpha-2 formatında) ve bayrak görselinin URL'sini içerir.
●
Kullanım Senaryoları:
○
Takım ülkeleri listesini görüntülemek.
○
Belirli bir ülkeye ait takımları filtrelemek.
○
Ülke bayraklarını kullanıcı arayüzünde görselleştirmek.
25. Teams Statistics Endpoint (Takım İstatistikleri):
●
Amaç: Belirli bir lig, sezon ve takım için istatistikleri çekmek için kullanılır.
●
Özellikler:
○
Takım ID'si, adı, lig bilgisi, son maçların formu, oynanan maç sayıları, goller, en büyük galibiyet/mağlubiyetler, penaltı istatistikleri, dizilişler, sarı/kırmızı kart dağılımları gibi detaylı bilgileri içerir.
26. Leagues Endpoint (Lig Listeleri):
●
Amaç: Sistemdeki tüm liglerin listesini getirir.
●
Parametreler:
○
id: Lig ID'si.
○
name: Lig ismi.
○
country: Ülke adı.
○
code: Ülke kodu.
○
season: Sezon yılı.
○
team: Takım ID'si.
○
type: Lig tipi (league/cup).
○
current: Aktif sezonlar (true).
○
search: Lig veya ülke ismi.
○
last: Son X lig/kupa.
Örnek Python Betikleri ve PyQt5 Uygulamaları:
Her bir uç nokta için, kaynak dokümanlarda örnek Python betikleri ve PyQt5 uygulamaları sunulmuştur. Bu örnekler, verilerin nasıl çekileceği, işleneceği ve kullanıcı arayüzünde nasıl görüntüleneceği konusunda detaylı bilgi vermektedir.
Sonuç:
Bu detaylı brifing dokümanı, çeşitli futbol API uç noktalarını anlamak, bu uç noktaları kullanarak veri çekmek ve bu verileri analiz etmek için gerekli bilgileri sunmaktadır. Her bir uç noktanın amacı, özellikleri, parametreleri, kullanım alanları, diğer uç noktalarla karşılaştırması ve örnek kodları detaylı bir şekilde ele alınmıştır. Bu doküman, futbol veri analizi yapmak isteyen herkes için önemli bir kaynak olacaktır.

--------------------------------------------------------------------------------
Futbol Veri Analizi
Metinler, futbol istatistikleri ve maç bilgilerine erişimi sağlayan çeşitli veri kaynaklarından alınmış örnekleri göstermektedir. Lig sıralamaları, maç istatistikleri, oyuncu performansları, kadrolar, sakatlık durumları, ve hatta maç tahmini gibi birçok farklı veri türünü kapsamaktadır. Takım ve oyuncu bazlı istatistikler ayrıntılı olarak sunulmuştur. Kısacası, kapsamlı bir futbol veritabanı sisteminin farklı bileşenlerini yansıtmaktadır. Baştan sona tüm veriler, futbol maçları ve oyuncuları ile ilgilidir.

--------------------------------------------------------------------------------
Futbol Veri API'si Referansı
Detaylı API Briefing Dokümanı
Bu doküman, sağlanan kaynaklardan elde edilen bilgilere dayanarak, futbol verileri için kullanılan çeşitli API endpoint'lerini ve bunların kullanım alanlarını detaylı bir şekilde özetlemektedir. Amaç, bu endpoint'lerin özelliklerini, amaçlarını, parametrelerini ve kullanım önerilerini net bir şekilde anlamaktır.
Genel API Kavramları
●
Endpoint: API'nin belirli bir kaynağına (örneğin, maçlar, oyuncular, ligler) erişmek için kullanılan URL.
●
Parametreler: API'ye gönderilen isteklere eklenen, verileri filtrelemek veya özelleştirmek için kullanılan bilgiler (örneğin, lig ID'si, oyuncu ID'si, tarih).
●
Pagination: Büyük veri setlerini yönetmek için kullanılan sayfalama mekanizması.
●
Rate Limit: API'ye yapılan isteklerin sıklığını sınırlayan bir mekanizma.
●
JSON: API'den dönen verilerin standart formatı.
Endpoint İncelemeleri
Aşağıda, kaynaklarda bahsedilen her endpoint'in detaylı bir incelemesi sunulmaktadır:
1. /odds/bets Endpoint
●
Amaç: Maç öncesi bahis türlerinin listesini almak.
●
Özellikler:
○
Sadece maç öncesi oranlar için geçerli.
○
odds/live endpointi ile uyumlu değil.
○
Haftada birkaç kez güncellenir.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
id: Bahis türünün ID'sini belirtir.
○
search: Bahis türü adıyla arama yapmak için kullanılır (en az 3 karakter).
●
Örnek Kullanım: "Maç sonucu", "Alt/Üst" gibi farklı bahis türlerini listelemek.
2. /odds/bookmakers Endpoint
●
Amaç: Mevcut tüm bahis şirketlerinin listesini almak.
●
Özellikler:
○
Bahis şirketi ID'leri, diğer oran endpointlerinde filtreleme için kullanılabilir.
○
Birkaç günde bir güncellenir.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
id: Belirli bir bahis şirketinin ID'sini belirtir.
○
search: Bahis şirketinin adıyla arama yapmak için kullanılır (en az 3 karakter).
●
Örnek Kullanım: Belirli bir bahis şirketinin oranlarını almak için öncelikle bahis şirketi ID'sini almak.
3. /odds/mapping Endpoint
●
Amaç: Belirli bir tarihteki veya ligdeki maçların ID'lerini sağlar.
●
Özellikler:
○
odds endpointi için gerekli olan fixture ID'lerini sağlar.
○
Lig ID'leri, sezon bilgileri, maç tarihleri ve son güncellenme zamanı gibi bilgiler içerir.
○
Günlük olarak güncellenir.
○
Pagination (100 sonuç/sayfa) destekler.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
page: Sayfa numarası (pagination için).
●
Örnek Kullanım: Belirli bir ligdeki tüm maçların oranlarını almak için öncelikle bu endpointten maç ID'lerini almak.
●
"Bu uç nokta, oran sorguları için gerekli olan fixture ID'leri ve league ID'leri gibi verileri almayı kolaylaştırır."
4. /odds Endpoint
●
Amaç: Belirli bir maç, lig veya tarihe göre ön maç oranlarını sağlar.
●
Özellikler:
○
Maçtan 1-14 gün öncesine kadar olan oranlar görüntülenebilir. 7 günlük geçmiş oranlar da mevcuttur.
○
Her 3 saatte bir güncellenir.
○
Pagination (10 sonuç/sayfa) destekler.
○
Bahis şirketi, bahis türü, lig veya tarih bazında filtreleme imkanı sunar.
○
Fixture bilgileri, bahis şirketi bilgileri, bahis türleri ve oranlar gibi detaylar içerir.
●
Parametreler:
○
fixture: Maç ID'si.
○
league: Lig ID'si.
○
season: Sezon.
○
date: Tarih (YYYY-MM-DD formatında).
○
timezone: Zaman dilimi.
○
bookmaker: Bahis şirketi ID'si.
○
bet: Bahis türü ID'si.
○
page: Sayfa numarası.
●
Örnek Kullanım: Belirli bir maçın, belirlenen bahis şirketindeki, maç sonucu oranlarını almak.
5. /odds/live Endpoint
●
Amaç: Canlı maçlar için oranlar ve bahis türlerini sağlar.
●
Özellikler:
○
Oranlar, maçın ilerleyişine göre düzenli olarak güncellenir (5-60 saniye arası).
○
Belirli bir maç (fixture ID) için mevcut tüm oranları ve bu oranlarla ilişkili bahis türlerini döndürür.
○
Dinamik veri sağlar.
●
Örnek Kullanım: Devam eden bir maçın anlık oranlarını almak.
●
"Canlı olarak devam eden maçlarda oranları ve bahis seçeneklerini görüntülemek"
6. /odds/live/bets Endpoint
●
Amaç: Mevcut tüm bahis türlerinin listesini almak.
●
Özellikler:
○
Statik veri sağlar (oran bilgisi içermez).
○
60 saniyede bir güncellenir.
○
Tüm bahis türlerinin ID ve isimlerini döndürür.
●
Örnek Kullanım: Hangi bahis türlerinin desteklendiğini öğrenmek ve filtreleme için ID'leri elde etmek.
●
"Kullanıcıların hangi bahis türlerinin desteklendiğini öğrenmesi"
7. Top Yellow Cards Endpoint
●
Amaç: Bir ligde veya turnuvada en çok sarı kart gören oyuncuları listelemek.
●
Özellikler:
○
Sarı kart sayısı, kırmızı kart sayısı, oynanan maç sayısı ve dakika süresi dikkate alınarak sıralama yapılır.
○
Günde bir kez çağrılması önerilir.
●
Örnek Kullanım: Sarı kart cezası sınırındaki oyuncuları tespit etmek.
8. Top Red Cards Endpoint
●
Amaç: Bir ligde veya turnuvada en çok kırmızı kart gören oyuncuları listelemek.
●
Özellikler:
○
Kırmızı kart sayısı, sarı kart sayısı, oynanan maç sayısı ve dakika süresi dikkate alınarak sıralama yapılır.
○
Günde bir kez çağrılması önerilir.
●
Örnek Kullanım: Disiplin sorunları olan oyuncuları belirlemek.
9. Top Assists Endpoint
●
Amaç: Bir ligde veya kupada en çok asist yapan ilk 20 oyuncuyu listelemek.
●
Özellikler:
○
Oyuncuların pas kabiliyetlerini ve takıma yaptıkları katkıyı değerlendirmek için kullanılır.
●
Örnek Kullanım: Asist potansiyeli yüksek oyuncuları belirlemek.
10. Top Scorers Endpoint
●
Amaç: Bir ligde veya kupada en çok gol atan ilk 20 oyuncuyu listelemek.
●
Özellikler:
○
Oyuncuların gol, asist, dakika ve diğer istatistiklerini karşılaştırarak analiz yapma.
●
Örnek Kullanım: Gol krallarını ve takıma en çok katkı sağlayan forvetleri belirlemek.
11. Players/Teams Endpoint
●
Amaç: Bir oyuncunun kariyerindeki takımların ve bu takımlarda oynadığı sezonların listesini almak.
●
Özellikler:
○
Oyuncunun transfer geçmişini ve kariyer rotasını analiz etmek için kullanılır.
●
Örnek Kullanım: Oyuncunun hangi takımlarda ve hangi sezonlarda oynadığını görmek.
12. Statistics Endpoint (Oyuncu İstatistikleri)
●
Amaç: Oyuncuların performans verilerine ulaşmak.
●
Özellikler:
○
Belirli bir oyuncunun, belirli bir sezon, takım ve ligdeki performans verilerini içerir.
○
Oyuncunun performansına göre hesaplanan bir rating değeri de sağlar.
●
Parametreler:
○
player: Oyuncu ID'si.
○
search: oyuncu ismi ile arama (en az 3 karakter)
○
team: Takım ID'si.
○
league: Lig ID'si.
○
season: sezon bilgisi
●
Örnek Kullanım: Oyuncunun sezonluk ya da maç bazlı performanslarını analiz etmek.
●
"Oyuncuların sezonluk ve maç bazlı istatistiklerine erişim sağlar."
13. Profiles Endpoint
●
Amaç: Futbol oyuncularının profilleriyle ilgili kapsamlı bilgi sağlar.
●
Özellikler:
○
Oyuncuların temel biyografik bilgileri, fiziksel özellikleri, pozisyonları ve fotoğrafları gibi detaylar içerir.
○
Haftada birkaç kez güncellenir.
○
Haftada 1 çağrı önerilir.
●
Parametreler:
○
player : Oyuncu ID'si
○
search : Soyadı ile arama
●
Örnek Kullanım: Oyuncu bilgilerini görüntülemek ve istatistiksel verileri bağlamak.
●
"Oyuncuların biyografik ve fiziksel özelliklerine erişim sağlar."
14. Seasons Endpoint
●
Amaç: Bir oyuncunun istatistiklerinin bulunduğu tüm sezonların listesini almak.
●
Özellikler:
○
Geçmiş yıllara ait istatistiksel verilerin analizi ve karşılaştırılması için kullanılır.
○
Günlük olarak güncellenir.
●
Parametreler:
○
player : Oyuncu ID'si (opsiyonel)
●
Örnek Kullanım: Oyuncunun kariyer gelişimini sezona göre analiz etmek.
●
"Seasons Endpoint, tarihsel verilerin analizinde önemli bir araçtır."
15. Predictions Endpoint
●
Amaç: Belirli bir maç için tahminleri getirmek.
●
Özellikler:
○
İstatistiksel analiz, son maçlar, takım performansı, oyuncu verileri ve Poisson dağılımı gibi algoritmalarla tahminler oluşturulur.
○
Bahis oranları kullanılmaz.
●
Örnek Kullanım: Maç sonucu, gol tahmini ve takım performansı hakkında analiz yapmak.
●
"Predictions Endpoint futbol analizleri için stratejik bir araçtır."
16. Injuries Endpoint
●
Amaç: Maçlara katılamayan veya katılımı şüpheli olan oyuncuların listesini almak.
●
Özellikler:
○
Oyuncunun adı, ID'si, fotoğrafı, katılmama nedeni, maç, takım ve lig bilgileri içerir.
○
4 saatte bir güncellenir.
○
Günde 1 çağrı önerilir.
○
Missing Fixture (kesin olarak katılamıyor) ve Questionable (durumu belirsiz) olarak 2 tür veri sunar.
●
Parametreler:
○
league: lig ID'si
○
season : sezon yılı
○
fixture : Maç ID'si
○
team: Takım ID'si
○
player: Oyuncu ID'si
○
date : Tarih (YYYY-MM-DD)
○
ids: 20 maç ID'si
○
timezone: Saat dilimi
●
Örnek Kullanım: Sakat veya cezalı oyuncuları tespit etmek ve maç kadrolarını analiz etmek.
●
"maç öncesi analizler için eksik oyuncu bilgilerini detaylı bir şekilde sunar"
17. Statistics Endpoint (Maç İstatistikleri)
●
Amaç: Belirli bir maça (fixture ID) ait detaylı istatistikleri getirmek.
●
Özellikler:
○
Şutlar, paslar, fauller, kartlar gibi istatistikleri içerir.
○
1 dakika aralıklarla güncellenir.
○
Canlı maçlar için dakikada 1 çağrı, normal kullanımda günde 1 çağrı önerilir.
○
Parametreler:
* fixture: maç ID'si
* team : takım ID'si (opsiyonel)
●
Örnek Kullanım: Maçın gidişatını ve takımların performansını analiz etmek.
18. Fixtures Endpoint
●
Amaç: Bir ligin, takımın veya turnuvanın maç programlarını almak.
●
Özellikler:
○
Maçların tarihleri, saatleri, statüleri ve skor bilgileri alınabilir.
○
Batch işlemler (tek seferde en fazla 20 fixture ID) gerektirebilir.
○
Parametreler:
* league: Lig ID'si.
* season: Sezon.
* team: Takım ID'si.
* date: Tarih (YYYY-MM-DD).
* from: Başlangıç tarihi
* to : Bitiş tarihi
* status : Maç durumu
* timezone : Zaman dilimi
●
Örnek Kullanım: Maç programı hazırlamak, canlı skor uygulamaları geliştirmek ve sezon analizleri yapmak.
19. Rounds Endpoint
●
Amaç: Belirli bir ligin veya kupanın mevcut sezonundaki tur listesini almak.
●
Özellikler:
○
Fikstür endpoint'i ile birlikte kullanılarak belirli bir turun maçlarını çekebilirsiniz.
○
Her turun başlangıç/bitiş tarihini alabilirsiniz (dates=true parametresi).
●
Parametreler:* league: Lig ID'si. * season: Sezon. * current : Aktif tur * dates : Her turun başlangıç ve bitiş tarihini almak için
●
Örnek Kullanım: Belirli bir turdaki maçları çekmek için öncelikle bu endpointten tur bilgilerini almak.
20. Standings Endpoint
●
Amaç: Tüm aktif liglerin puan durumlarını almak.
●
Özellikler:
○
Lig veya kupaların mevcut sıralama tablolarını döner.
○
Eğer bir ligde birden fazla sıralama varsa (grup aşaması gibi), bu veriler de döner.
●
Örnek Kullanım: Liglerin puan durumlarını görüntülemek ve karşılaştırmak.
21. Teams Countries Endpoint
●
Amaç: teams endpoint'inde kullanılabilecek ülkelerin listesini almak.
●
Özellikler:
○
Ülkelerin adlarını, ISO Alpha-2 formatındaki kodlarını ve bayrak görsellerinin URL'lerini içerir.
●
Örnek Kullanım: Belirli bir ülkedeki takımları filtrelemek ve ülke bayraklarını arayüzde göstermek.
22. Teams Statistics Endpoint
●
Amaç: Belirli bir lig, sezon ve takım için istatistikleri çekmek.
●
Özellikler:
○
Takım formu, oynanan maç sayısı, gol istatistikleri, penaltı bilgileri ve kart bilgileri gibi detaylar içerir.
●
Parametreler:
○
league: Lig ID'si
○
season: Sezon
○
team: Takım ID'si
●
Örnek Kullanım: Takımların performansını analiz etmek ve karşılaştırmak.
23. Leagues Endpoint
●
Amaç: Tüm liglerin listesini almak.
●
Özellikler:
○
Aktif sezonları veya tüm sezonları listelenebilir.
○
Ülke, lig adı, sezon gibi parametrelerle filtreleme yapılabilir.
○
Her ligin kendine özel ID’si vardır.
●
Parametreler:
○
id : Lig ID'si
○
name: Lig ismi
○
country : ülke ismi
○
code : ülke kodu
○
season : sezon
○
team : takım ID'si
○
type : lig tipi (league / cup)
○
current: aktif sezonları listeleme (true)
○
search: arama
○
last: son X ligi getirme
24. Events Endpoint
●
Amaç: Belirli bir maça (fixture ID) ait tüm olayları getirmek.
●
Özellikler:
○
Olay Türleri:
* Goal : Normal gol, kendi kalesine, penaltı vb.
* Card: Sarı ve kırmızı kart
* Subst: oyuncu değişikliği
* Var: Var kararları
●
Parametreler:
○
fixture: Maç ID'si (zorunlu).
○
team: Takım ID'si (opsiyonel).
○
player: oyuncu ID'si (opsiyonel)
○
type: Olay tipi (opsiyonel)
25. Lineups Endpoint
●
Amaç: Maç kadrosu ve formasyon bilgilerini getirir
●
Parametreler:
○
fixture: Maç ID'si (zorunlu).
●
Özellikler:
○
ilk 11, yedek oyuncular, teknik direktör bilgilerini içerir
○
15 dakika aralıklarla güncellenir.
Önemli Notlar:
●
Çoğu endpoint için, veri çekme işlemleri için Python betikleri ve PyQt5 arayüz örnekleri sunulmuştur.
●
Rate limitlere dikkat edilmeli ve aşırı sorgulardan kaçınılmalıdır. API'lerin önerilen çağrı frekanslarına uyunuz.
●
API'den dönen veriler, kullanıcı dostu bir şekilde gösterilmek üzere genellikle tablo (QTableWidget) veya liste formatında düzenlenmiştir.
●
Hata yönetimi (try-except blokları ve hata mesajları) betiklerde bulunmaktadır.
●
Çeşitli endpointler, futbol analizi ve uygulamaları için geniş bir yelpazede veri sağlamaktadır.
Bu detaylı inceleme, API'leri kullanırken ihtiyaç duyulan temel bilgileri sağlamayı amaçlamaktadır. Her endpointin kendine özgü kullanım senaryoları ve parametreleri mevcuttur. İhtiyaçlarınıza uygun olan endpointleri seçerek, futbol verilerini analiz etme ve kullanma sürecinizi optimize edebilirsiniz.

--------------------------------------------------------------------------------
Futbol Veri API'si Referansı
Detaylı API Briefing Dokümanı
Bu doküman, sağlanan kaynaklardan elde edilen bilgilere dayanarak, futbol verileri için kullanılan çeşitli API endpoint'lerini ve bunların kullanım alanlarını detaylı bir şekilde özetlemektedir. Amaç, bu endpoint'lerin özelliklerini, amaçlarını, parametrelerini ve kullanım önerilerini net bir şekilde anlamaktır.
Genel API Kavramları
●
Endpoint: API'nin belirli bir kaynağına (örneğin, maçlar, oyuncular, ligler) erişmek için kullanılan URL.
●
Parametreler: API'ye gönderilen isteklere eklenen, verileri filtrelemek veya özelleştirmek için kullanılan bilgiler (örneğin, lig ID'si, oyuncu ID'si, tarih).
●
Pagination: Büyük veri setlerini yönetmek için kullanılan sayfalama mekanizması.
●
Rate Limit: API'ye yapılan isteklerin sıklığını sınırlayan bir mekanizma.
●
JSON: API'den dönen verilerin standart formatı.
Endpoint İncelemeleri
Aşağıda, kaynaklarda bahsedilen her endpoint'in detaylı bir incelemesi sunulmaktadır:
1. /odds/bets Endpoint
●
Amaç: Maç öncesi bahis türlerinin listesini almak.
●
Özellikler:
○
Sadece maç öncesi oranlar için geçerli.
○
odds/live endpointi ile uyumlu değil.
○
Haftada birkaç kez güncellenir.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
id: Bahis türünün ID'sini belirtir.
○
search: Bahis türü adıyla arama yapmak için kullanılır (en az 3 karakter).
●
Örnek Kullanım: "Maç sonucu", "Alt/Üst" gibi farklı bahis türlerini listelemek.
2. /odds/bookmakers Endpoint
●
Amaç: Mevcut tüm bahis şirketlerinin listesini almak.
●
Özellikler:
○
Bahis şirketi ID'leri, diğer oran endpointlerinde filtreleme için kullanılabilir.
○
Birkaç günde bir güncellenir.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
id: Belirli bir bahis şirketinin ID'sini belirtir.
○
search: Bahis şirketinin adıyla arama yapmak için kullanılır (en az 3 karakter).
●
Örnek Kullanım: Belirli bir bahis şirketinin oranlarını almak için öncelikle bahis şirketi ID'sini almak.
3. /odds/mapping Endpoint
●
Amaç: Belirli bir tarihteki veya ligdeki maçların ID'lerini sağlar.
●
Özellikler:
○
odds endpointi için gerekli olan fixture ID'lerini sağlar.
○
Lig ID'leri, sezon bilgileri, maç tarihleri ve son güncellenme zamanı gibi bilgiler içerir.
○
Günlük olarak güncellenir.
○
Pagination (100 sonuç/sayfa) destekler.
○
Günde maksimum 1 çağrı önerilir.
●
Parametreler:
○
page: Sayfa numarası (pagination için).
●
Örnek Kullanım: Belirli bir ligdeki tüm maçların oranlarını almak için öncelikle bu endpointten maç ID'lerini almak.
●
"Bu uç nokta, oran sorguları için gerekli olan fixture ID'leri ve league ID'leri gibi verileri almayı kolaylaştırır."
4. /odds Endpoint
●
Amaç: Belirli bir maç, lig veya tarihe göre ön maç oranlarını sağlar.
●
Özellikler:
○
Maçtan 1-14 gün öncesine kadar olan oranlar görüntülenebilir. 7 günlük geçmiş oranlar da mevcuttur.
○
Her 3 saatte bir güncellenir.
○
Pagination (10 sonuç/sayfa) destekler.
○
Bahis şirketi, bahis türü, lig veya tarih bazında filtreleme imkanı sunar.
○
Fixture bilgileri, bahis şirketi bilgileri, bahis türleri ve oranlar gibi detaylar içerir.
●
Parametreler:
○
fixture: Maç ID'si.
○
league: Lig ID'si.
○
season: Sezon.
○
date: Tarih (YYYY-MM-DD formatında).
○
timezone: Zaman dilimi.
○
bookmaker: Bahis şirketi ID'si.
○
bet: Bahis türü ID'si.
○
page: Sayfa numarası.
●
Örnek Kullanım: Belirli bir maçın, belirlenen bahis şirketindeki, maç sonucu oranlarını almak.
5. /odds/live Endpoint
●
Amaç: Canlı maçlar için oranlar ve bahis türlerini sağlar.
●
Özellikler:
○
Oranlar, maçın ilerleyişine göre düzenli olarak güncellenir (5-60 saniye arası).
○
Belirli bir maç (fixture ID) için mevcut tüm oranları ve bu oranlarla ilişkili bahis türlerini döndürür.
○
Dinamik veri sağlar.
●
Örnek Kullanım: Devam eden bir maçın anlık oranlarını almak.
●
"Canlı olarak devam eden maçlarda oranları ve bahis seçeneklerini görüntülemek"
6. /odds/live/bets Endpoint
●
Amaç: Mevcut tüm bahis türlerinin listesini almak.
●
Özellikler:
○
Statik veri sağlar (oran bilgisi içermez).
○
60 saniyede bir güncellenir.
○
Tüm bahis türlerinin ID ve isimlerini döndürür.
●
Örnek Kullanım: Hangi bahis türlerinin desteklendiğini öğrenmek ve filtreleme için ID'leri elde etmek.
●
"Kullanıcıların hangi bahis türlerinin desteklendiğini öğrenmesi"
7. Top Yellow Cards Endpoint
●
Amaç: Bir ligde veya turnuvada en çok sarı kart gören oyuncuları listelemek.
●
Özellikler:
○
Sarı kart sayısı, kırmızı kart sayısı, oynanan maç sayısı ve dakika süresi dikkate alınarak sıralama yapılır.
○
Günde bir kez çağrılması önerilir.
●
Örnek Kullanım: Sarı kart cezası sınırındaki oyuncuları tespit etmek.
8. Top Red Cards Endpoint
●
Amaç: Bir ligde veya turnuvada en çok kırmızı kart gören oyuncuları listelemek.
●
Özellikler:
○
Kırmızı kart sayısı, sarı kart sayısı, oynanan maç sayısı ve dakika süresi dikkate alınarak sıralama yapılır.
○
Günde bir kez çağrılması önerilir.
●
Örnek Kullanım: Disiplin sorunları olan oyuncuları belirlemek.
9. Top Assists Endpoint
●
Amaç: Bir ligde veya kupada en çok asist yapan ilk 20 oyuncuyu listelemek.
●
Özellikler:
○
Oyuncuların pas kabiliyetlerini ve takıma yaptıkları katkıyı değerlendirmek için kullanılır.
●
Örnek Kullanım: Asist potansiyeli yüksek oyuncuları belirlemek.
10. Top Scorers Endpoint
●
Amaç: Bir ligde veya kupada en çok gol atan ilk 20 oyuncuyu listelemek.
●
Özellikler:
○
Oyuncuların gol, asist, dakika ve diğer istatistiklerini karşılaştırarak analiz yapma.
●
Örnek Kullanım: Gol krallarını ve takıma en çok katkı sağlayan forvetleri belirlemek.
11. Players/Teams Endpoint
●
Amaç: Bir oyuncunun kariyerindeki takımların ve bu takımlarda oynadığı sezonların listesini almak.
●
Özellikler:
○
Oyuncunun transfer geçmişini ve kariyer rotasını analiz etmek için kullanılır.
●
Örnek Kullanım: Oyuncunun hangi takımlarda ve hangi sezonlarda oynadığını görmek.
12. Statistics Endpoint (Oyuncu İstatistikleri)
●
Amaç: Oyuncuların performans verilerine ulaşmak.
●
Özellikler:
○
Belirli bir oyuncunun, belirli bir sezon, takım ve ligdeki performans verilerini içerir.
○
Oyuncunun performansına göre hesaplanan bir rating değeri de sağlar.
●
Parametreler:
○
player: Oyuncu ID'si.
○
search: oyuncu ismi ile arama (en az 3 karakter)
○
team: Takım ID'si.
○
league: Lig ID'si.
○
season: sezon bilgisi
●
Örnek Kullanım: Oyuncunun sezonluk ya da maç bazlı performanslarını analiz etmek.
●
"Oyuncuların sezonluk ve maç bazlı istatistiklerine erişim sağlar."
13. Profiles Endpoint
●
Amaç: Futbol oyuncularının profilleriyle ilgili kapsamlı bilgi sağlar.
●
Özellikler:
○
Oyuncuların temel biyografik bilgileri, fiziksel özellikleri, pozisyonları ve fotoğrafları gibi detaylar içerir.
○
Haftada birkaç kez güncellenir.
○
Haftada 1 çağrı önerilir.
●
Parametreler:
○
player : Oyuncu ID'si
○
search : Soyadı ile arama
●
Örnek Kullanım: Oyuncu bilgilerini görüntülemek ve istatistiksel verileri bağlamak.
●
"Oyuncuların biyografik ve fiziksel özelliklerine erişim sağlar."
14. Seasons Endpoint
●
Amaç: Bir oyuncunun istatistiklerinin bulunduğu tüm sezonların listesini almak.
●
Özellikler:
○
Geçmiş yıllara ait istatistiksel verilerin analizi ve karşılaştırılması için kullanılır.
○
Günlük olarak güncellenir.
●
Parametreler:
○
player : Oyuncu ID'si (opsiyonel)
●
Örnek Kullanım: Oyuncunun kariyer gelişimini sezona göre analiz etmek.
●
"Seasons Endpoint, tarihsel verilerin analizinde önemli bir araçtır."
15. Predictions Endpoint
●
Amaç: Belirli bir maç için tahminleri getirmek.
●
Özellikler:
○
İstatistiksel analiz, son maçlar, takım performansı, oyuncu verileri ve Poisson dağılımı gibi algoritmalarla tahminler oluşturulur.
○
Bahis oranları kullanılmaz.
●
Örnek Kullanım: Maç sonucu, gol tahmini ve takım performansı hakkında analiz yapmak.
●
"Predictions Endpoint futbol analizleri için stratejik bir araçtır."
16. Injuries Endpoint
●
Amaç: Maçlara katılamayan veya katılımı şüpheli olan oyuncuların listesini almak.
●
Özellikler:
○
Oyuncunun adı, ID'si, fotoğrafı, katılmama nedeni, maç, takım ve lig bilgileri içerir.
○
4 saatte bir güncellenir.
○
Günde 1 çağrı önerilir.
○
Missing Fixture (kesin olarak katılamıyor) ve Questionable (durumu belirsiz) olarak 2 tür veri sunar.
●
Parametreler:
○
league: lig ID'si
○
season : sezon yılı
○
fixture : Maç ID'si
○
team: Takım ID'si
○
player: Oyuncu ID'si
○
date : Tarih (YYYY-MM-DD)
○
ids: 20 maç ID'si
○
timezone: Saat dilimi
●
Örnek Kullanım: Sakat veya cezalı oyuncuları tespit etmek ve maç kadrolarını analiz etmek.
●
"maç öncesi analizler için eksik oyuncu bilgilerini detaylı bir şekilde sunar"
17. Statistics Endpoint (Maç İstatistikleri)
●
Amaç: Belirli bir maça (fixture ID) ait detaylı istatistikleri getirmek.
●
Özellikler:
○
Şutlar, paslar, fauller, kartlar gibi istatistikleri içerir.
○
1 dakika aralıklarla güncellenir.
○
Canlı maçlar için dakikada 1 çağrı, normal kullanımda günde 1 çağrı önerilir.
○
Parametreler:
* fixture: maç ID'si
* team : takım ID'si (opsiyonel)
●
Örnek Kullanım: Maçın gidişatını ve takımların performansını analiz etmek.
18. Fixtures Endpoint
●
Amaç: Bir ligin, takımın veya turnuvanın maç programlarını almak.
●
Özellikler:
○
Maçların tarihleri, saatleri, statüleri ve skor bilgileri alınabilir.
○
Batch işlemler (tek seferde en fazla 20 fixture ID) gerektirebilir.
○
Parametreler:
* league: Lig ID'si.
* season: Sezon.
* team: Takım ID'si.
* date: Tarih (YYYY-MM-DD).
* from: Başlangıç tarihi
* to : Bitiş tarihi
* status : Maç durumu
* timezone : Zaman dilimi
●
Örnek Kullanım: Maç programı hazırlamak, canlı skor uygulamaları geliştirmek ve sezon analizleri yapmak.
19. Rounds Endpoint
●
Amaç: Belirli bir ligin veya kupanın mevcut sezonundaki tur listesini almak.
●
Özellikler:
○
Fikstür endpoint'i ile birlikte kullanılarak belirli bir turun maçlarını çekebilirsiniz.
○
Her turun başlangıç/bitiş tarihini alabilirsiniz (dates=true parametresi).
●
Parametreler:* league: Lig ID'si. * season: Sezon. * current : Aktif tur * dates : Her turun başlangıç ve bitiş tarihini almak için
●
Örnek Kullanım: Belirli bir turdaki maçları çekmek için öncelikle bu endpointten tur bilgilerini almak.
20. Standings Endpoint
●
Amaç: Tüm aktif liglerin puan durumlarını almak.
●
Özellikler:
○
Lig veya kupaların mevcut sıralama tablolarını döner.
○
Eğer bir ligde birden fazla sıralama varsa (grup aşaması gibi), bu veriler de döner.
●
Örnek Kullanım: Liglerin puan durumlarını görüntülemek ve karşılaştırmak.
21. Teams Countries Endpoint
●
Amaç: teams endpoint'inde kullanılabilecek ülkelerin listesini almak.
●
Özellikler:
○
Ülkelerin adlarını, ISO Alpha-2 formatındaki kodlarını ve bayrak görsellerinin URL'lerini içerir.
●
Örnek Kullanım: Belirli bir ülkedeki takımları filtrelemek ve ülke bayraklarını arayüzde göstermek.
22. Teams Statistics Endpoint
●
Amaç: Belirli bir lig, sezon ve takım için istatistikleri çekmek.
●
Özellikler:
○
Takım formu, oynanan maç sayısı, gol istatistikleri, penaltı bilgileri ve kart bilgileri gibi detaylar içerir.
●
Parametreler:
○
league: Lig ID'si
○
season: Sezon
○
team: Takım ID'si
●
Örnek Kullanım: Takımların performansını analiz etmek ve karşılaştırmak.
23. Leagues Endpoint
●
Amaç: Tüm liglerin listesini almak.
●
Özellikler:
○
Aktif sezonları veya tüm sezonları listelenebilir.
○
Ülke, lig adı, sezon gibi parametrelerle filtreleme yapılabilir.
○
Her ligin kendine özel ID’si vardır.
●
Parametreler:
○
id : Lig ID'si
○
name: Lig ismi
○
country : ülke ismi
○
code : ülke kodu
○
season : sezon
○
team : takım ID'si
○
type : lig tipi (league / cup)
○
current: aktif sezonları listeleme (true)
○
search: arama
○
last: son X ligi getirme
24. Events Endpoint
●
Amaç: Belirli bir maça (fixture ID) ait tüm olayları getirmek.
●
Özellikler:
○
Olay Türleri:
* Goal : Normal gol, kendi kalesine, penaltı vb.
* Card: Sarı ve kırmızı kart
* Subst: oyuncu değişikliği
* Var: Var kararları
●
Parametreler:
○
fixture: Maç ID'si (zorunlu).
○
team: Takım ID'si (opsiyonel).
○
player: oyuncu ID'si (opsiyonel)
○
type: Olay tipi (opsiyonel)
25. Lineups Endpoint
●
Amaç: Maç kadrosu ve formasyon bilgilerini getirir
●
Parametreler:
○
fixture: Maç ID'si (zorunlu).
●
Özellikler:
○
ilk 11, yedek oyuncular, teknik direktör bilgilerini içerir
○
15 dakika aralıklarla güncellenir.
Önemli Notlar:
●
Çoğu endpoint için, veri çekme işlemleri için Python betikleri ve PyQt5 arayüz örnekleri sunulmuştur.
●
Rate limitlere dikkat edilmeli ve aşırı sorgulardan kaçınılmalıdır. API'lerin önerilen çağrı frekanslarına uyunuz.
●
API'den dönen veriler, kullanıcı dostu bir şekilde gösterilmek üzere genellikle tablo (QTableWidget) veya liste formatında düzenlenmiştir.
●
Hata yönetimi (try-except blokları ve hata mesajları) betiklerde bulunmaktadır.
●
Çeşitli endpointler, futbol analizi ve uygulamaları için geniş bir yelpazede veri sağlamaktadır.
Bu detaylı inceleme, API'leri kullanırken ihtiyaç duyulan temel bilgileri sağlamayı amaçlamaktadır. Her endpointin kendine özgü kullanım senaryoları ve parametreleri mevcuttur. İhtiyaçlarınıza uygun olan endpointleri seçerek, futbol verilerini analiz etme ve kullanma sürecinizi optimize edebilirsiniz.

--------------------------------------------------------------------------------
maç öncesi sunulan bahis türlerini listeler
Detaylı İnceleme ve Karşılaştırma: Bets Endpoint
Bets Endpoint Özellikleri
1.
Amaç:
●
/odds/bets endpointi, pre-match odds (maç öncesi oranlar) için mevcut bahis türlerini getirir.
●
ID'ler, odds endpointinde kullanılabilir ancak odds/live (canlı oranlar) endpointi ile uyumlu değildir.
1.
Güncellenme Sıklığı: Haftada birkaç kez güncellenir.
2.
Kullanım Önerisi: Günde maksimum 1 çağrı yapılması önerilir.
3.
Desteklenen Parametreler:
●
id: Bahis türünün kimliğini belirtir.
●
search: Bahis türü adı üzerinden arama yapmak için kullanılır. En az 3 karakter uzunluğunda bir string bekler.
Parametre Detayları
Parametre Tür Açıklama Zorunlu mu? Örnek id String Belirli bir bahis türünü tanımlar. Hayır "5" search String Bahis türü adına göre arama yapar (3+ karakter). Hayır "under" JSON Yanıt Örneği
Başarılı bir çağrı durumunda JSON yanıtı aşağıdaki gibi görünebilir:
{
"get": "odds/bets",
"parameters": {
"search": "under"
},
"errors": [],
"results": 7,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"id": 5,
"name": "Goals Over/Under"
},
{
"id": 6,
"name": "Goals Over/Under First Half"
},
{
"id": 26,
"name": "Goals Over/Under - Second Half"
},
{
"id": 45,
"name": "Corners Over Under"
},
{
"id": 57,
"name": "Home Corners Over/Under"
},
{
"id": 58,
"name": "Away Corners Over/Under"
},
{
"id": 74,
"name": "10 Over/Under"
}
]
}
Hatalı bir çağrı durumunda şu şekilde yanıt alınabilir:
{
"get": "odds/bets",
"parameters": [],
"errors": [],
"results": 0,
"paging": {
"current": 1,
"total": 1
},
"response": []
}
Diğer Endpointler ile Karşılaştırma
Endpoint Amaç Güncelleme Sıklığı Önemli Parametreler Kapsam odds/live Canlı oranlar. 5-60 saniyede bir fixture, league, bet Canlı maçlar için oranlar odds/live/bets Canlı bahis türlerini getirir. 60 saniyede bir id, search Canlı oranlara uygun bahis türleri odds Maç öncesi oranlar. 3 saatte bir fixture, league, bet Maç öncesi oranlar odds/bets Maç öncesi bahis türlerini getirir. Haftada birkaç kez id, search Pre-match bahis türleri odds/bookmakers Mevcut bahisçileri getirir. Haftada birkaç kez id, search Bahisçiler Fark:
●
odds/live/bets canlı oranlar için bahis türlerini verirken, odds/bets yalnızca maç öncesi oranlar için bahis türlerini verir.
●
odds/bookmakers bahisçileri hedef alırken, odds/bets bahis türlerine odaklanır.
Python Betiği
import http.client
import json
# API Bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_bets(search=None, bet_id=None):
"""
Mevcut bahis türlerini API'den çeker.
"""
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = "/odds/bets"
if search:
endpoint += f"?search={search}"
elif bet_id:
endpoint += f"?id={bet_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
def display_bets(data):
"""
Gelen JSON verilerini konsola yazdırır.
"""
if data.get("results", 0) == 0:
print("Hiç sonuç bulunamadı.")
return
print(f"Toplam Bahis Türü: {data['results']}")
for bet in data.get("response", []):
print(f"ID: {bet['id']} | İsim: {bet['name']}")
# Örnek Kullanım
bet_data = fetch_bets(search="under")
display_bets(bet_data)
PyQt5 Arayüz Betiği
from PyQt5 import QtWidgets
import http.client
import json
import sys
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_bets(search=None, bet_id=None):
"""
Mevcut bahis türlerini API'den çeker.
"""
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
endpoint = "/odds/bets"
if search:
endpoint += f"?search={search}"
elif bet_id:
endpoint += f"?id={bet_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
class BetsApp(QtWidgets.QWidget):
def __init__(self):
super().__init__()
self.init_ui()
def init_ui(self):
self.setWindowTitle("Bahis Türleri")
self.setGeometry(100, 100, 800, 600)
self.layout = QtWidgets.QVBoxLayout()
self.search_input = QtWidgets.QLineEdit(self)
self.search_input.setPlaceholderText("Bahis türü adı girin (min. 3 karakter)")
self.layout.addWidget(self.search_input)
self.fetch_button = QtWidgets.QPushButton("Bahis Türlerini Getir", self)
self.fetch_button.clicked.connect(self.get_bets)
self.layout.addWidget(self.fetch_button)
self.result_box = QtWidgets.QTextEdit(self)
self.layout.addWidget(self.result_box)
self.setLayout(self.layout)
def get_bets(self):
search = self.search_input.text()
try:
data = fetch_bets(search=search)
self.result_box.clear()
if data.get("results", 0) == 0:
self.result_box.append("Sonuç bulunamadı.")
return
for bet in data.get("response", []):
self.result_box.append(f"ID: {bet['id']} | İsim: {bet['name']}")
except Exception as e:
self.result_box.append(f"Veri Alınamadı: {e}")
if __name__ == "__main__":
app = QtWidgets.QApplication(sys.argv)
window = BetsApp()
window.show()
sys.exit(app.exec_())
Sonuç
●
odds/bets, maç öncesi oranlar için bahis türlerini döner ve bu türlerin ID'leri diğer odds endpointlerinde filtre olarak kullanılabilir.
●
Canlı oranlar ile uyumsuzdur.
●
Detaylı Python betiği ve kullanıcı dostu PyQt5 arayüzü sağlanmıştır.

--------------------------------------------------------------------------------
BahisFirmalarınılisteler
Detaylı İnceleme ve Betik: Bookmakers Endpoint
Bookmakers Endpoint Özellikleri
1.
Amaç: /odds/bookmakers endpointi, mevcut tüm bahisçiler (bookmakers) listesini getirir. Bahisçi ID'leri, diğer oranlarla ilgili endpointlerde filtreleme amacıyla kullanılabilir.
2.
Güncellenme Sıklığı: Birkaç günde bir güncellenir.
3.
Kullanım Önerisi: Günde maksimum 1 çağrı yapılması önerilir.
●
Kullanılabilir Parametreler:id: Belirli bir bahisçinin ID'sini belirtir.
●
search: En az 3 karakter uzunluğunda bir bahisçi adıyla arama yapılır.
Parametre Detayları
Parametre Tür Açıklama Zorunlu mu? Örnek id Integer Bahisçinin kimliği. Hayır 6 search String Bahisçi adı (min. 3 karakter). Hayır "Bwi" JSON Yanıt Örneği
Başarılı bir çağrı durumunda, JSON yanıtı aşağıdaki gibi olacaktır:
{
"get": "odds/bookmakers",
"parameters": [],
"errors": [],
"results": 5,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"id": 1,
"name": "Bet365"
},
{
"id": 2,
"name": "William Hill"
},
{
"id": 3,
"name": "Bwin"
},
{
"id": 4,
"name": "Pinnacle"
},
{
"id": 5,
"name": "Unibet"
}
]
}
Başarısız bir çağrıda şu örnek bir hata yanıtı dönebilir:
{
"get": "odds/bookmakers",
"parameters": [],
"errors": {
"time": "2019-11-26T00:00:00+00:00",
"bug": "This is on our side, please report us this bug on https://dashboard.api-football.com",
"report": "odds/bookmakers"
},
"results": 0,
"paging": {
"current": 1,
"total": 1
},
"response": []
}
Bookmakers Endpoint ile İlgili Farklılıklar
Endpoint Amaç Güncelleme Sıklığı Önemli Parametreler odds/live Canlı maçlar için oranları getirir. 5-60 saniyede bir fixture, league, bet odds/live/bets Canlı oranlar için mevcut bahis türlerini getirir. 60 saniyede bir id, search odds Önceden belirlenmiş oranları getirir. 3 saatte bir fixture, league, bet odds/mapping Kullanılabilir maç ID'lerini getirir. Günlük page odds/bookmakers Mevcut bahisçileri getirir. Haftalık id, search Python Betiği
import http.client
import json
# API Bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_bookmakers(search=None, bookmaker_id=None):
"""
Mevcut bahisçileri API'den çeker.
"""
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = "/odds/bookmakers"
if search:
endpoint += f"?search={search}"
elif bookmaker_id:
endpoint += f"?id={bookmaker_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
def display_bookmakers(data):
"""
Gelen JSON verilerini konsola yazdırır.
"""
if data.get("results", 0) == 0:
print("Hiç sonuç bulunamadı.")
return
print(f"Toplam Bahisçi: {data['results']}")
for bookmaker in data.get("response", []):
print(f"ID: {bookmaker['id']} | İsim: {bookmaker['name']}")
# Örnek Kullanım
bookmaker_data = fetch_bookmakers()
display_bookmakers(bookmaker_data)
PyQt5 Arayüz Betiği
from PyQt5 import QtWidgets
import http.client
import json
import sys
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_bookmakers(search=None, bookmaker_id=None):
"""
Mevcut bahisçileri API'den çeker.
"""
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
endpoint = "/odds/bookmakers"
if search:
endpoint += f"?search={search}"
elif bookmaker_id:
endpoint += f"?id={bookmaker_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
class BookmakersApp(QtWidgets.QWidget):
def __init__(self):
super().__init__()
self.init_ui()
def init_ui(self):
self.setWindowTitle("Bahisçiler")
self.setGeometry(100, 100, 800, 600)
self.layout = QtWidgets.QVBoxLayout()
self.search_input = QtWidgets.QLineEdit(self)
self.search_input.setPlaceholderText("Bahisçi adı girin (min. 3 karakter)")
self.layout.addWidget(self.search_input)
self.fetch_button = QtWidgets.QPushButton("Bahisçileri Getir", self)
self.fetch_button.clicked.connect(self.get_bookmakers)
self.layout.addWidget(self.fetch_button)
self.result_box = QtWidgets.QTextEdit(self)
self.layout.addWidget(self.result_box)
self.setLayout(self.layout)
def get_bookmakers(self):
search = self.search_input.text()
try:
data = fetch_bookmakers(search=search)
self.result_box.clear()
if data.get("results", 0) == 0:
self.result_box.append("Sonuç bulunamadı.")
return
for bookmaker in data.get("response", []):
self.result_box.append(f"ID: {bookmaker['id']} | İsim: {bookmaker['name']}")
except Exception as e:
self.result_box.append(f"Veri Alınamadı: {e}")
if __name__ == "__main__":
app = QtWidgets.QApplication(sys.argv)
window = BookmakersApp()
window.show()
sys.exit(app.exec_())
Sonuç
1.
Parametre Analizi: ID ve arama parametreleri ile ilgili detaylar eklendi.
2.
Python Betiği: Bahisçi bilgilerini çeken ve gösteren bir betik hazırlandı.
3.
PyQt5 Uygulaması: Kullanıcıdan bahisçi adı veya ID girişi alıp API sonuçlarını gösteren bir GUI oluşturuldu.

--------------------------------------------------------------------------------
tarihe yada lige göre bahislere açık maçları yada benzeri bilgileri getirir.
Açıklama: /odds/mapping Endpoint
1. /odds/mapping Endpoint'in Amacı
●
Belirli bir tarihteki veya ligdeki maçların ID'lerini sağlar. Bu maç ID'leri, oranlar için kullanılan diğer uç noktalarla (örneğin /odds) filtreleme amacıyla kullanılır.
●
Kapsam: Lig ID'leri, sezon bilgileri, maç tarihleri ve son güncellenme zamanı gibi temel bilgiler sunar.
●
Kullanım Amacı: Bu uç nokta, oran sorguları için gerekli olan fixture ID'leri ve league ID'leri gibi verileri almayı kolaylaştırır.
2. Genel Özellikler
Özellik Açıklama Pagination: 100 sonuç/sayfa. Güncellenme Sıklığı: Günlük olarak güncellenir. Amaç: Oran verileri için kullanılabilir maç ID'lerini sağlar. Kapsam: Tüm ligler ve sezonlar. 3. Parametreler
Parametre Açıklama Örnek page Sayfa numarası (pagination) 1 Örnek JSON Yanıt
{
"get": "odds/mapping",
"parameters": [],
"errors": [],
"results": 129,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"league": {
"id": 106,
"season": 2019
},
"fixture": {
"id": 154507,
"date": "2020-05-29T18:30:00+00:00",
"timestamp": 1590777000
},
"update": "2020-05-15T09:52:28+00:00"
}
]
}
Önceki Yapılarla Karşılaştırma
Özellik /odds/live /odds/live/bets /odds /odds/mapping Amaç: Canlı maçlar için oranlar. Canlı bahis türlerini listeler. Ön maç oranlarını listeler. Oranlar için kullanılabilir maç ID'lerini sağlar. Dinamik/Statik: Dinamik, 5-60 saniye arası güncelleme. Statik, 60 saniyede bir güncellenir. Statik, 3 saatte bir güncellenir. Statik, günlük olarak güncellenir. Kapsam: Belirli bir maçın oranları. Canlı bahis türleri. Tarih, lig veya maç bazlı ön oranlar. Maç ve lig bilgileri. Pagination: Yok. Yok. 10 sonuç/sayfa. 100 sonuç/sayfa. Güncellenme Sıklığı: 5-60 saniye 60 saniye 3 saat Günlük. Örnek Kullanım Alanı: Canlı maç oranları. Canlı bahis türü analizi. Ön maç analizleri. Oran sorguları için fixture ID'leri. Python Betiği
1. /odds/mapping İçin Python Betiği
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
# Maç ID'lerini al
def fetch_mapping_data(page=1):
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = f"/odds/mapping?page={page}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# Mapping verilerini yazdır
def display_mapping(data):
print("Mapping Verileri:")
for item in data.get("response", []):
league = item["league"]
fixture = item["fixture"]
print(f"Lig ID: {league['id']}, Sezon: {league['season']}")
print(f" Maç ID: {fixture['id']}, Tarih: {fixture['date']}")
print(f" Son Güncelleme: {item['update']}")
# Örnek Kullanım
data = fetch_mapping_data(page=1)
display_mapping(data)
PyQt5 Arayüz
2. PyQt5 Uygulama Betiği
Aşağıdaki PyQt5 uygulaması, /odds/mapping endpointinden alınan verileri kullanıcı arayüzünde gösterir:
from PyQt5 import QtWidgets
import http.client
import json
import sys
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_mapping_data(page=1):
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
endpoint = f"/odds/mapping?page={page}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
class MappingApp(QtWidgets.QWidget):
def __init__(self):
super().__init__()
self.init_ui()
def init_ui(self):
self.setWindowTitle("Mapping Verileri")
self.setGeometry(100, 100, 800, 600)
self.layout = QtWidgets.QVBoxLayout()
self.page_input = QtWidgets.QLineEdit(self)
self.page_input.setPlaceholderText("Sayfa numarasını girin")
self.layout.addWidget(self.page_input)
self.fetch_button = QtWidgets.QPushButton("Mapping Verilerini Getir", self)
self.fetch_button.clicked.connect(self.get_mapping)
self.layout.addWidget(self.fetch_button)
self.result_box = QtWidgets.QTextEdit(self)
self.layout.addWidget(self.result_box)
self.setLayout(self.layout)
def get_mapping(self):
page = self.page_input.text() or "1"
data = fetch_mapping_data(page=int(page))
self.result_box.clear()
for item in data.get("response", []):
league = item["league"]
fixture = item["fixture"]
self.result_box.append(f"Lig ID: {league['id']}, Sezon: {league['season']}")
self.result_box.append(f" Maç ID: {fixture['id']}, Tarih: {fixture['date']}")
self.result_box.append(f" Son Güncelleme: {item['update']}")
self.result_box.append("-" * 50)
if __name__ == "__main__":
app = QtWidgets.QApplication(sys.argv)
window = MappingApp()
window.show()
sys.exit(app.exec_())
Sonuç
1.
Detaylı Açıklama: /odds/mapping, oranlarla ilgili sorgular için gerekli olan maç ID'lerini ve lig bilgilerini sağlar.
2.
Python Betiği: Veriyi çekip konsola yazdırır.
3.
PyQt5 Arayüzü: Kullanıcı girişine dayalı olarak verileri görselleştirir.
Haklısınız, parametre kısmında detaylı bir inceleme yapmamış olabilirim. Şimdi tüm detaylarıyla yeniden gözden geçirip, açıklama ve betiği güncelleyeceğim.
Detaylı Parametre İncelemesi
Parametreler
Parametre Tür Açıklama Varsayılan Değer Örnek page Integer Sayfa numarası (pagination). 1 2 Endpoint Özellikleri
1.
Amaç: /odds/mapping endpointi, oranlar ile ilgili kullanılabilir tüm maç ID'lerini, lig ID'lerini ve tarih bilgilerini sağlar.
2.
Pagination: Bu endpoint 100 sonuç/sayfa olacak şekilde yapılandırılmıştır. Büyük veri setleri arasında gezinmek için kullanılır.
3.
Güncellenme Sıklığı: Günlük olarak yenilenir.
4.
Kullanım Önerisi: Günlük olarak maksimum 1 kez çağrılması önerilir.
JSON Yanıt Örneği
{
"get": "odds/mapping",
"parameters": [],
"errors": [],
"results": 129,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"league": {
"id": 106,
"season": 2019
},
"fixture": {
"id": 154507,
"date": "2020-05-29T18:30:00+00:00",
"timestamp": 1590777000
},
"update": "2020-05-15T09:52:28+00:00"
},
{
"league": {
"id": 271,
"season": 2019
},
"fixture": {
"id": 182564,
"date": "2020-05-27T18:00:00+00:00",
"timestamp": 1590602400
},
"update": "2020-05-15T09:52:17+00:00"
}
]
}
Python Betiği
Güncellenmiş Python Betiği
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_mapping_data(page=1):
"""
Mapping verilerini çeker.
"""
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = f"/odds/mapping?page={page}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
def display_mapping(data):
"""
Gelen JSON verilerini konsola yazdırır.
"""
print(f"Toplam Sonuçlar: {data['results']}")
for item in data.get("response", []):
league = item["league"]
fixture = item["fixture"]
print(f"Lig ID: {league['id']} | Sezon: {league['season']}")
print(f"Maç ID: {fixture['id']} | Tarih: {fixture['date']}")
print(f"Son Güncelleme: {item['update']}")
print("-" * 50)
# Örnek Kullanım
page_number = 1 # Kullanıcıdan alınabilir
data = fetch_mapping_data(page=page_number)
display_mapping(data)
PyQt5 Arayüz
Güncellenmiş PyQt5 Uygulama Betiği
from PyQt5 import QtWidgets
import http.client
import json
import sys
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_mapping_data(page=1):
"""
Mapping verilerini çeker.
"""
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
endpoint = f"/odds/mapping?page={page}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
class MappingApp(QtWidgets.QWidget):
def __init__(self):
super().__init__()
self.init_ui()
def init_ui(self):
self.setWindowTitle("Mapping Verileri")
self.setGeometry(100, 100, 800, 600)
self.layout = QtWidgets.QVBoxLayout()
self.page_input = QtWidgets.QLineEdit(self)
self.page_input.setPlaceholderText("Sayfa numarasını girin")
self.layout.addWidget(self.page_input)
self.fetch_button = QtWidgets.QPushButton("Mapping Verilerini Getir", self)
self.fetch_button.clicked.connect(self.get_mapping)
self.layout.addWidget(self.fetch_button)
self.result_box = QtWidgets.QTextEdit(self)
self.layout.addWidget(self.result_box)
self.setLayout(self.layout)
def get_mapping(self):
page = self.page_input.text() or "1"
try:
data = fetch_mapping_data(page=int(page))
self.result_box.clear()
self.result_box.append(f"Toplam Sonuçlar: {data['results']}")
for item in data.get("response", []):
league = item["league"]
fixture = item["fixture"]
self.result_box.append(f"Lig ID: {league['id']} | Sezon: {league['season']}")
self.result_box.append(f"Maç ID: {fixture['id']} | Tarih: {fixture['date']}")
self.result_box.append(f"Son Güncelleme: {item['update']}")
self.result_box.append("-" * 50)
except Exception as e:
self.result_box.append(f"Veri Alınamadı: {e}")
if __name__ == "__main__":
app = QtWidgets.QApplication(sys.argv)
window = MappingApp()
window.show()
sys.exit(app.exec_())
Sonuç
1.
Detaylı Parametre İncelemesi: page parametresine dikkat edildi ve kapsamlı bir açıklama eklendi.
2.
Python Betiği: API'den mapping verilerini çekmek için sade ve işlevsel bir betik hazırlandı.
3.
PyQt5 Uygulaması: Kullanıcı girişi ile sayfa bilgisi alınıp veriler bir arayüzde gösterildi.

--------------------------------------------------------------------------------
Bahisbülteni
Açıklama: /odds Endpoint
1. /odds Endpoint'in Amacı
●
Belirli bir maç, lig veya tarihe göre ön maç oranları sağlar.
●
Tarih aralığı: Maçtan 1-14 gün öncesine kadar olan oranlar görüntülenebilir. Ayrıca, 7 günlük geçmiş oranlar da mevcuttur.
●
Kullanıcılar bahis şirketi, bahis türü, lig veya tarih bazında filtreleme yaparak veri alabilir.
2. Genel Özellikler
●
Pagination: Sonuçlar sayfa sayısına göre bölünmüştür (10 sonuç/sayfa).
●
Güncellenme Sıklığı: Her 3 saatte bir yenilenir.
●
Kapsam: Ön maç oranlarını içerir, canlı bahis oranlarını kapsamaz.
●
Detaylı Bilgiler:Fixture (Maç) Bilgileri: Maçın tarihi, zamanı ve lig bilgisi.
●
Bookmaker (Bahis Şirketi) Bilgileri: Oranları sağlayan bahis şirketinin adı ve ID'si.
●
Bet (Bahis) Türleri: Örneğin, "Match Winner", "Exact Score", "Over/Under".
●
Odds (Oranlar): Her bahis türüne ait oranlar ve seçenekler.
Örnek Parametreler
Parametre Açıklama Örnek fixture Maç ID'si 157140 league Lig ID'si 39 season Sezon 2020 date Tarih (YYYY-MM-DD) formatında 2020-05-15 timezone Zaman dilimi UTC bookmaker Bahis şirketi ID'si 6 bet Bahis türü ID'si 1 page Sayfa numarası (pagination) 1 Önceki Uç Noktalarla Karşılaştırma
Özellik /odds/live /odds/live/bets /odds Amaç Canlı maçlar için oranları sağlar. Canlı bahis türlerini listeler. Ön maç oranlarını sağlar. Dinamik/Statik Dinamik, 5-60 saniyede bir güncellenir. Statik, canlı bahis türlerini döndürür. Statik, 3 saatte bir güncellenir. Kapsam Belirli bir maç için oranlar. Genel bahis türlerini ID ve isim olarak döndürür. Belirli bir tarih, lig veya maç için ön maç oranları. Güncellenme Sıklığı 5-60 saniye 60 saniye 3 saat Örnek Çıktı Oranlar, bahis türleri, maç bilgisi. Bahis türlerinin ID ve isimleri. Ön maç oranları, bahis türleri, bahis şirketleri. Python Betiği
1. /odds İçin Python Betiği
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
# Ön maç oranlarını al
def fetch_pre_match_odds(fixture_id, league_id, season, bookmaker_id):
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = f"/odds?fixture={fixture_id}&league={league_id}&season={season}&bookmaker={bookmaker_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# Oranları yazdır
def display_odds(data):
print("Ön Maç Oranları:")
for response in data.get("response", []):
league = response["league"]
fixture = response["fixture"]
print(f"Lig: {league['name']} ({league['country']})")
print(f"Maç: {fixture['id']} - Tarih: {fixture['date']}")
for bookmaker in response["bookmakers"]:
print(f" Bahis Şirketi: {bookmaker['name']}")
for bet in bookmaker["bets"]:
print(f" Bahis Türü: {bet['name']}")
for value in bet["values"]:
print(f" Seçenek: {value['value']} - Oran: {value['odd']}")
# Örnek Kullanım
fixture_id = 157140
league_id = 39
season = 2020
bookmaker_id = 6
data = fetch_pre_match_odds(fixture_id, league_id, season, bookmaker_id)
display_odds(data)
PyQt5 Arayüz
PyQt5 Uygulama Betiği
Aşağıdaki betik, /odds uç noktasını kullanarak ön maç oranlarını gösteren bir PyQt5 arayüzü içerir:
from PyQt5 import QtWidgets
import http.client
import json
import sys
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_pre_match_odds(fixture_id, league_id, season, bookmaker_id):
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
endpoint = f"/odds?fixture={fixture_id}&league={league_id}&season={season}&bookmaker={bookmaker_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
class OddsApp(QtWidgets.QWidget):
def __init__(self):
super().__init__()
self.init_ui()
def init_ui(self):
self.setWindowTitle("Ön Maç Oranları")
self.setGeometry(100, 100, 600, 400)
self.layout = QtWidgets.QVBoxLayout()
self.fixture_input = QtWidgets.QLineEdit(self)
self.fixture_input.setPlaceholderText("Maç ID'sini girin")
self.layout.addWidget(self.fixture_input)
self.league_input = QtWidgets.QLineEdit(self)
self.league_input.setPlaceholderText("Lig ID'sini girin")
self.layout.addWidget(self.league_input)
self.season_input = QtWidgets.QLineEdit(self)
self.season_input.setPlaceholderText("Sezonu girin (YYYY)")
self.layout.addWidget(self.season_input)
self.bookmaker_input = QtWidgets.QLineEdit(self)
self.bookmaker_input.setPlaceholderText("Bahis Şirketi ID'sini girin")
self.layout.addWidget(self.bookmaker_input)
self.fetch_odds_btn = QtWidgets.QPushButton("Oranları Getir", self)
self.fetch_odds_btn.clicked.connect(self.get_odds)
self.layout.addWidget(self.fetch_odds_btn)
self.result_box = QtWidgets.QTextEdit(self)
self.layout.addWidget(self.result_box)
self.setLayout(self.layout)
def get_odds(self):
fixture_id = self.fixture_input.text()
league_id = self.league_input.text()
season = self.season_input.text()
bookmaker_id = self.bookmaker_input.text()
data = fetch_pre_match_odds(fixture_id, league_id, season, bookmaker_id)
self.result_box.clear()
for response in data.get("response", []):
league = response["league"]
fixture = response["fixture"]
self.result_box.append(f"Lig: {league['name']} ({league['country']})")
self.result_box.append(f"Maç: {fixture['id']} - Tarih: {fixture['date']}")
for bookmaker in response["bookmakers"]:
self.result_box.append(f" Bahis Şirketi: {bookmaker['name']}")
for bet in bookmaker["bets"]:
self.result_box.append(f" Bahis Türü: {bet['name']}")
for value in bet["values"]:
self.result_box.append(f" {value['value']} - Oran: {value['odd']}")
if __name__ == "__main__":
app = QtWidgets.QApplication(sys.argv)
window = OddsApp()
window.show()
sys.exit(app.exec_())
Sonuç
1.
Detaylı Açıklama: /odds uç noktası ön maç oranları için kullanılır ve bahis türleri, oranlar, lig bilgisi gibi kapsamlı bilgi sağlar.
2.
Python Betiği: Veriyi çeken ve konsola yazdıran bir betik.
3.
PyQt5 Arayüzü: Kullanıcı girişine dayalı olarak oranları görselleştiren bir masaüstü uygulaması.

--------------------------------------------------------------------------------
Bahistürlerininlistelenmesi
Karşılaştırma: /odds/live vs /odds/live/bets
API'nin iki uç noktası arasında temel farkları ayrıntılı bir şekilde açıklayacağım:
1. /odds/live Endpoint
●
Amaç: Canlı maçlar için oranlar ve bahis türlerini sağlar.
●
Detaylar:
●
Oranlar: Belirli bir maç (fixture ID) için mevcut tüm oranları ve bu oranlarla ilişkili bahis türlerini döndürür.
●
Bahis Türleri: Her bahis türü, oranlar ve olası seçeneklerle detaylandırılır.
●
Dinamik Veri: Maçın ilerleyen durumuna göre oranlar düzenli olarak güncellenir (ör. gol atıldığında oran değişir).
●
Güncellenme Sıklığı: 5-60 saniye arasında.
●
Örnek Çıktı: Belirli bir maç için bahis türleri (ör. Over/Under Line, Match Corners) ve oran değerleri.
●
Kullanım Alanları:
●
Canlı olarak devam eden maçlarda oranları ve bahis seçeneklerini görüntülemek.
●
Anlık olarak bahis oynayan kullanıcılar için güncel bilgi sağlamak.
2. /odds/live/bets Endpoint
●
Amaç: Mevcut tüm bahis türlerini döndürür.
●
Detaylar:
●
Bahis Türleri: Bu uç nokta, tüm bahis türlerinin bir listesini sağlar (ör. "Over/Under Line", "1x2 Extra Time").
●
Statik Veri: Bu uç nokta bahis türlerini listeler, ancak belirli bir maç için oran bilgisi içermez.
●
Güncellenme Sıklığı: 60 saniye.
●
Örnek Çıktı: Tüm bahis türlerinin ID ve isimleri.
●
Kullanım Alanları:
●
Kullanıcıların hangi bahis türlerinin desteklendiğini öğrenmesi.
●
Bahis türlerini filtrelemek için kullanılacak ID'lerin elde edilmesi.
Temel Farklar
Özellik /odds/live /odds/live/bets Amaç Belirli maçlar için oranları ve bahis türlerini döndürmek. Mevcut tüm bahis türlerinin listesini sağlamak. Dinamik/Statik Dinamik (maçın durumuna göre değişir). Statik (bahis türleri sabittir, oran içermez). Güncellenme Sıklığı 5-60 saniye. 60 saniye. Kapsam Belirli bir maç ile sınırlıdır. Genel bahis türlerini kapsar. Çıktı İçeriği Oranlar, bahis türleri, maç bilgisi. Bahis türlerinin ID ve isimleri. Python Betikleri
1. /odds/live İçin Python Betiği
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
# Canlı oranları al
def fetch_live_odds(fixture_id):
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = f"/odds/live?fixture={fixture_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# Oranları yazdır
def display_live_odds(data):
print("Canlı Oranlar:")
for response in data["response"]:
print(f"Maç ID: {response['fixture']['id']}")
for odd in response["odds"]:
print(f" Bahis Türü: {odd['name']}")
for value in odd["values"]:
print(f" Seçenek: {value['value']} - Oran: {value['odd']}")
# Örnek Kullanım
fixture_id = input("Maç ID'sini girin: ")
data = fetch_live_odds(fixture_id)
display_live_odds(data)
2. /odds/live/bets İçin Python Betiği
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
# Bahis türlerini al
def fetch_bet_types():
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
conn.request("GET", "/odds/live/bets", headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# Bahis türlerini yazdır
def display_bet_types(data):
print("Mevcut Bahis Türleri:")
for bet in data["response"]:
print(f"ID: {bet['id']} - Adı: {bet['name']}")
# Örnek Kullanım
data = fetch_bet_types()
display_bet_types(data)
PyQt5 Arayüz Tasarımı
Aşağıda her iki uç noktayı da entegre eden bir PyQt5 uygulaması verilmiştir:
from PyQt5 import QtWidgets
import http.client
import json
import sys
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
def fetch_live_odds(fixture_id):
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
conn.request("GET", f"/odds/live?fixture={fixture_id}", headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
def fetch_bet_types():
conn = http.client.HTTPSConnection(API_HOST)
headers = {'x-rapidapi-host': API_HOST, 'x-rapidapi-key': API_KEY}
conn.request("GET", "/odds/live/bets", headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
class OddsApp(QtWidgets.QWidget):
def __init__(self):
super().__init__()
self.init_ui()
def init_ui(self):
self.setWindowTitle("Canlı Bahis Uygulaması")
self.setGeometry(100, 100, 600, 400)
self.layout = QtWidgets.QVBoxLayout()
self.fixture_input = QtWidgets.QLineEdit(self)
self.fixture_input.setPlaceholderText("Maç ID'sini girin")
self.layout.addWidget(self.fixture_input)
self.fetch_odds_btn = QtWidgets.QPushButton("Oranları Getir", self)
self.fetch_odds_btn.clicked.connect(self.get_live_odds)
self.layout.addWidget(self.fetch_odds_btn)
self.fetch_bets_btn = QtWidgets.QPushButton("Bahis Türlerini Getir", self)
self.fetch_bets_btn.clicked.connect(self.get_bet_types)
self.layout.addWidget(self.fetch_bets_btn)
self.result_box = QtWidgets.QTextEdit(self)
self.layout.addWidget(self.result_box)
self.setLayout(self.layout)
def get_live_odds(self):
fixture_id = self.fixture_input.text()
data = fetch_live_odds(fixture_id)
self.result_box.clear()
for response in data.get("response", []):
self.result_box.append(f"Maç ID: {response['fixture']['id']}")
for odd in response["odds"]:
self.result_box.append(f" Bahis Türü: {odd['name']}")
for value in odd["values"]:
self.result_box.append(f" {value['value']} - Oran: {value['odd']}\n")
def get_bet_types(self):
data = fetch_bet_types()
self.result_box.clear()
for bet in data.get("response", []):
self.result_box.append(f"ID: {bet['id']} - Adı: {bet['name']}")
if __name__ == "__main__":
app = QtWidgets.QApplication(sys.argv)
window = OddsApp()
window.show()
sys.exit(app.exec_())
Sonuç
1.
Aradaki Fark: /odds/live oranları ve bahis türlerini döndürürken, /odds/live/bets yalnızca bahis türlerini ID ve isim olarak döndürür.
2.
Python Betikleri: Her iki uç nokta için işlevsel betikler sağlandı.
3.
PyQt5 Uygulaması: Kullanıcı arayüzü ile canlı oranlar ve bahis türleri aynı pencerede gösterilebilir.

--------------------------------------------------------------------------------
Canlıbahisoranları
Bu yapı, bir futbol karşılaşması sırasında canlı oranlar ile ilgili bilgileri almak için kullanılan bir API sorgusunu temsil eder. Aşağıda bu yapı detaylıca açıklanmış ve buna uygun bir Python betiği hazırlanmıştır.
Yapının Detaylı Açıklaması
Bu API uç noktası, devam eden bir futbol maçına ilişkin canlı bahis oranlarını almayı sağlar. Aşağıda, yapının ana unsurları açıklanmıştır:
Anahtar Kavramlar
1.
Fixture (Maç):
●
fixture: Maçın kimlik numarasıdır. Bu ID üzerinden canlı oranlar sorgulanır.
●
Örneğin: fixture=721238.
1.
League (Lig):
●
league: Lig kimlik numarasıdır. Canlı oranlar belirli bir lig bazında da sorgulanabilir.
1.
Bet (Bahis):
●
bet: Bahis türü ID'sidir. Örneğin, gol sayısı, korner sayısı gibi bahisler sorgulanabilir.
1.
Odds (Oranlar):
●
Her bir bahis türü, çeşitli olasılıkları (values) içerir.
●
Her olasılığın:
●
value: Bahis seçeneği (örneğin, "Over" veya "Under").
●
odd: Bahis oranı.
●
handicap: Bahis türüne özgü engel değeri.
●
main: Ana bahis mi değil mi bilgisini içerir (true veya false).
●
suspended: Bahsin geçici olarak durdurulup durdurulmadığını gösterir.
1.
Status (Durum):
●
stopped: Hakem tarafından durdurulmuş maçları belirtir.
●
blocked: Bahislerin geçici olarak engellenip engellenmediğini belirtir.
●
finished: Maçın tamamlanıp tamamlanmadığını belirtir.
Yanıt Formatı (JSON Örneği)
Bir sorgunun döndüreceği JSON yapısı şu şekildedir:
{
"get": "odds/live",
"parameters": {
"fixture": "721238"
},
"errors": [],
"results": 1,
"response": [
{
"fixture": {
"id": 721238,
"status": {
"long": "Second Half",
"elapsed": 62,
"seconds": "62:14"
}
},
"odds": [
{
"id": 36,
"name": "Over/Under Line",
"values": [
{
"value": "Over",
"odd": "1.975",
"handicap": "2",
"main": true,
"suspended": false
},
{
"value": "Under",
"odd": "2.25",
"handicap": "2",
"main": false,
"suspended": false
}
]
}
]
}
]
}
Betik: Detaylı Arayüzlü Python Uygulaması
Aşağıdaki Python betiği, kullanıcı dostu bir arayüzle canlı oranlar sorgulama ve görüntüleme imkanı sunar.
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "XxXxXxXxXxXxXxXxXxXxXxXx"
# Kullanıcıdan giriş al
def get_user_input():
print("Canlı Oranlar API'ye Hoşgeldiniz!")
fixture_id = input("Maç ID'sini girin (ör: 721238): ")
league_id = input("Lig ID'sini girin (ör: 39 - Premier League) veya boş bırakın: ")
bet_id = input("Bahis türü ID'sini girin (ör: 36 - Over/Under) veya boş bırakın: ")
return fixture_id, league_id, bet_id
# API çağrısı
def fetch_live_odds(fixture_id, league_id=None, bet_id=None):
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = f"/odds/live?fixture={fixture_id}"
if league_id:
endpoint += f"&league={league_id}"
if bet_id:
endpoint += f"&bet={bet_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# Oranları yazdır
def display_odds(data):
if data.get("results", 0) == 0:
print("Sonuç bulunamadı.")
return
print("\nCanlı Oranlar:")
for response in data["response"]:
fixture = response["fixture"]
print(f"\nMaç: {fixture['id']}")
print(f" Durum: {fixture['status']['long']}")
print(f" Süre: {fixture['status']['elapsed']} dakika")
for odd in response["odds"]:
print(f"\n Bahis Türü: {odd['name']}")
for value in odd["values"]:
print(f" Seçenek: {value['value']} | Oran: {value['odd']} | Handicap: {value['handicap']}")
print(f" Ana Bahis: {value['main']} | Durduruldu: {value['suspended']}")
# Ana işlev
def main():
fixture_id, league_id, bet_id = get_user_input()
data = fetch_live_odds(fixture_id, league_id, bet_id)
display_odds(data)
if __name__ == "__main__":
main()
Betiğin Kullanımı
1.
Betiği çalıştırdığınızda, sizden Fixture ID, League ID ve Bet ID bilgileri istenir.
2.
Girilen bilgiler doğrultusunda API'den canlı oranlar sorgulanır.
3.
Sonuçlar:
●
Maç durum bilgisi,
●
Bahis türü,
●
Olasılık detayları ve oranlar,
●
Bahis durum bilgisi (ör: durdurulmuş mu?) gibi bilgiler gösterilir.
Neden Önemli?
Bu detaylı açıklama ve betik sayesinde:
1.
Yapıyı Kavramak: Her parametrenin anlamını öğrenerek farklı uç noktalar arasındaki farkları kolayca anlayabilirsiniz.
2.
Görselleştirme: API'nin döndürdüğü veriyi bir arayüzde anlaşılır biçimde görüntüleyebilirsiniz.
3.
Karşılaştırma: Buna benzer diğer iki yapı ile farkları inceleyebilirsiniz (ör: geçmiş oranlar veya belirli bir maçın tüm bahisleri).
Aşağıda talebinize uygun olarak, verdiğiniz API anahtarıyla canlı oranlar sorgulama ve detaylı bir Python betiği hazırlanmıştır. Ayrıca, bahis türlerinin detaylı açıklamaları ve her bir bahis türünün olası değerleri ile beraber sunulmuştur.
API Yapısının Detaylı Açıklaması
Bahis Türleri ve Açıklamaları
1.
Over/Under Line (id: 36):
●
Belirli bir engel (handicap) değeri için toplam gol sayısının belirlenen değerin üstünde veya altında olup olmayacağını tahmin etme.
1.
Match Corners (id: 20):
●
Toplam korner sayısının belirli bir engel değerine göre "Over", "Under" veya "Exactly" (tam olarak) olması.
1.
Asian Handicap (id: 33):
●
Takımlara avantaj (pozitif/negatif puan) verilerek bahse konu takımın performansı üzerine bahis oynanması.
1.
Final Score (id: 23):
●
Maçın tam sonucunu tahmin etme (ör: 1-0, 2-2).
1.
Both Teams To Score (id: 69):
●
İki takımın da gol atıp atmayacağını tahmin etme ("Yes" veya "No").
1.
Goal Scorer (id: 46):
●
Maçta gol atan belirli oyuncuları tahmin etme.
1.
Double Chance (id: 72):
●
Ev sahibi veya deplasman galibiyeti ve beraberliği kapsayan bahis türü (ör: "Home or Draw").
1.
Next 10 Minutes Total (id: 65):
●
Önümüzdeki 10 dakikada belirli olayların (ör: korner, gol) sayısı üzerine bahis oynanması.
1.
Race to X Corners (id: 45, 44):
●
Belirli bir korner sayısına ilk ulaşacak takımı tahmin etme.
JSON Yanıt Formatının Analizi
Bir maç için sorgulama yaptığınızda, API aşağıdaki yapıyı döndürür:
{
"get": "odds/live",
"parameters": {
"fixture": "721238"
},
"results": 1,
"response": [
{
"fixture": {
"id": 721238,
"status": {
"long": "Second Half",
"elapsed": 62
}
},
"odds": [
{
"id": 36,
"name": "Over/Under Line",
"values": [
{
"value": "Over",
"odd": "1.975",
"handicap": "2",
"main": true,
"suspended": false
},
{
"value": "Under",
"odd": "2.25",
"handicap": "2",
"main": false,
"suspended": false
}
]
}
]
}
]
}
Python Betiği
Aşağıda, verdiğiniz API anahtarıyla canlı oranları sorgulayan bir Python betiği verilmiştir.
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
# Kullanıcıdan giriş al
def get_user_input():
print("Canlı Oranlar Sorgulama Aracı")
fixture_id = input("Maç ID'sini girin (ör: 721238): ")
return fixture_id
# API çağrısı
def fetch_live_odds(fixture_id):
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
endpoint = f"/odds/live?fixture={fixture_id}"
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# Oranları yazdır
def display_odds(data):
if data.get("results", 0) == 0:
print("Sonuç bulunamadı.")
return
print("\nCanlı Oranlar:")
for response in data["response"]:
fixture = response["fixture"]
print(f"\nMaç ID: {fixture['id']}")
print(f" Durum: {fixture['status']['long']}")
print(f" Süre: {fixture['status']['elapsed']} dakika")
print("\nBahis Türleri ve Oranlar:")
for odd in response["odds"]:
print(f"\n Bahis Türü: {odd['name']}")
for value in odd["values"]:
print(f" Seçenek: {value['value']} | Oran: {value['odd']} | Handicap: {value.get('handicap', 'N/A')}")
print(f" Ana Bahis: {value['main']} | Durduruldu: {value['suspended']}")
# Ana işlev
def main():
fixture_id = get_user_input()
data = fetch_live_odds(fixture_id)
display_odds(data)
if __name__ == "__main__":
main()
Betiğin Kullanımı
1.
Betiği çalıştırın:
●
Python betiğini çalıştırdıktan sonra sizden bir Fixture ID (Maç ID'si) istenecektir.
●
Örneğin, 721238 gibi bir ID girin.
1.
Sonuçlar:
●
Maçın durumu (ör: İkinci Yarı, dakika bilgisi),
●
Bahis türleri (ör: Over/Under Line, Match Corners),
●
Her bahis türü için olasılıklar (ör: Over, Under) ve bu olasılıkların oranları.
Ekstra Detaylar
Bahis Türlerinin Response Edilmesi
Bahis türleri odds anahtarında yer alır ve her biri ayrı bir id ve name ile tanımlanır.
●
id: Bahis türünü ayırt etmek için kullanılır.
●
values: Bahis seçeneklerini içerir (ör: Over, Under).
●
odd: Bahis oranını belirtir.
●
handicap: Belirli bir engel değeri (ör: -1, 2) içerebilir.
Aradaki Farkları Belirlemek
●
Bahis türlerinin detaylı bir şekilde dökümante edilmesi, diğer uç noktalarla farkları anlamak için temel teşkil eder.
●
Bu yapıda "canlı oranlar" (in-play odds) yalnızca devam eden maçlar için sunulurken, diğer uç noktalar geçmiş verileri veya tamamlanmış maçları da kapsayabilir.
Eğer başka uç noktalarla bu yapıyı kıyaslamamı veya daha fazla özellik eklememi isterseniz, lütfen belirtin! 😊

--------------------------------------------------------------------------------
sarkıvekırmızıkart
Haklısınız, detaylı açıklama ve Python betiğiyle formatta tam uyumlu bir yanıt hazırlıyorum. İşte açıklamalar ve ilgili Python betiği:
API'ler Hakkında Açıklamalar
1.
Top Yellow Cards Endpoint (En Çok Sarı Kart Alan Oyuncular):
●
Amaç: Bir ligde veya turnuvada en çok sarı kart gören oyuncuları döndürür.
●
Hesaplama Metodu:
1.
Oyuncunun gördüğü sarı kart sayısına göre sıralama yapılır.
2.
Diğer durumlar eşitse kırmızı kart sayısı dikkate alınır.
3.
Eşitlik devam ederse oyuncunun oynadığı maç sayısı ve dakika süresi analiz edilir.
●
Önerilen Çağrı Frekansı: Günde bir kez.
1.
Top Red Cards Endpoint (En Çok Kırmızı Kart Alan Oyuncular):
●
Amaç: Bir ligde veya turnuvada en çok kırmızı kart gören oyuncuları döndürür.
●
Hesaplama Metodu:
1.
Oyuncunun gördüğü kırmızı kart sayısına göre sıralama yapılır.
2.
Diğer durumlar eşitse sarı kart sayısı dikkate alınır.
3.
Oyuncunun oynadığı süre ve maç sayısı da sıralamaya katkı sağlar.
●
Önerilen Çağrı Frekansı: Günde bir kez.
Python Betiği
Aşağıdaki Python betiği, her iki API'ye çağrı yaparak verileri alır ve birleştirir. Sonuçlar kullanıcıya anlamlı bir şekilde birleştirilmiş formatta sunulur.
import http.client
import json
# API bilgileri
API_HOST = "v3.football.api-sports.io"
API_KEY = "XxXxXxXxXxXxXxXxXxXxXxXx"
# Lig ve sezon bilgileri
LEAGUE_ID = 61 # Ligue 1
SEASON = 2020
# API çağrısı yapan fonksiyon
def fetch_data(endpoint):
conn = http.client.HTTPSConnection(API_HOST)
headers = {
'x-rapidapi-host': API_HOST,
'x-rapidapi-key': API_KEY
}
conn.request("GET", endpoint, headers=headers)
res = conn.getresponse()
data = res.read()
return json.loads(data)
# En çok sarı kart ve kırmızı kart verilerini çek
yellow_cards_data = fetch_data(f"/players/topyellowcards?season={SEASON}&league={LEAGUE_ID}")
red_cards_data = fetch_data(f"/players/topredcards?season={SEASON}&league={LEAGUE_ID}")
# Verileri işleme ve birleştirme
yellow_cards_players = yellow_cards_data["response"]
red_cards_players = red_cards_data["response"]
# Sonuçları anlamlı bir formatta yazdır
print("En Çok Sarı Kart Alan Oyuncular:")
for player in yellow_cards_players:
player_info = player["player"]
stats = player["statistics"][0]
print(f"{player_info['name']} - {stats['team']['name']}: {stats['cards']['yellow']} sarı kart, {stats['cards']['red']} kırmızı kart")
print("\nEn Çok Kırmızı Kart Alan Oyuncular:")
for player in red_cards_players:
player_info = player["player"]
stats = player["statistics"][0]
print(f"{player_info['name']} - {stats['team']['name']}: {stats['cards']['red']} kırmızı kart, {stats['cards']['yellow']} sarı kart")
Betiğin Çıkışı
Betiği çalıştırdığınızda şu şekilde bir çıktı alırsınız:
En Çok Sarı Kart Alan Oyuncular
●
W. Faes - Reims: 10 sarı kart, 1 kırmızı kart
●
Álvaro González - Marseille: 10 sarı kart, 0 kırmızı kart
●
F. Medina - Lens: 9 sarı kart, 0 kırmızı kart
En Çok Kırmızı Kart Alan Oyuncular
●
Moreto Cassamã - Reims: 2 kırmızı kart, 8 sarı kart
●
A. Disasi - Monaco: 2 kırmızı kart, 4 sarı kart
●
D. Payet - Marseille: 2 kırmızı kart, 3 sarı kart
Bu betik, API'den alınan verileri JSON formatında işleyerek listeleme yapar. Her iki kategoriyi detaylıca karşılaştırabilir veya farklı analizler ekleyebilirsiniz.

--------------------------------------------------------------------------------
asistkralı
Top Assists Endpoint: Detaylı Açıklama ve Uygulama
1. Tanım ve Kullanım Amacı
Bu endpoint, belirli bir lig veya kupa için bir sezondaki en fazla asist yapan ilk 20 oyuncuyu döner. Bu veri, oyuncuların pas kabiliyetlerini ve takıma yaptıkları katkıyı değerlendirmek için kullanılır.
Kullanım Alanları
●
Asist Performansı Analizi: Oyuncuların asist sayılarını karşılaştırmak ve analiz etmek.
●
Takım Planlaması: En iyi asist yapan oyuncuların yetenekleri doğrultusunda taktik oluşturma.
●
Fantezi Lig Stratejileri: Asist yapma potansiyeli yüksek oyuncuların seçimi.
2. Güncelleme Sıklığı
●
Haftada birkaç kez güncellenir. Asist sayılarındaki değişikliklere hızlı bir şekilde erişim sağlar.
3. Önerilen Çağrı Limiti
●
Günlük 1 çağrı: Performansın çok sık değişmemesi nedeniyle yeterli olacaktır.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "players/topassists",
"parameters": {
"season": "2020",
"league": "61"
},
"errors": [],
"results": 20,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"player": {
"id": 667,
"name": "M. Depay",
"firstname": "Memphis",
"lastname": "Depay",
"age": 27,
"photo": "https://media.api-sports.io/football/players/667.png"
},
"statistics": [
{
"team": {
"id": 80,
"name": "Lyon",
"logo": "https://media.api-sports.io/football/teams/80.png"
},
"league": {
"id": 61,
"name": "Ligue 1",
"country": "France",
"logo": "https://media.api-sports.io/football/leagues/61.png",
"flag": "https://media.api-sports.io/flags/fr.svg"
},
"games": {
"appearences": 30,
"lineups": 26,
"minutes": 2313
},
"goals": {
"total": 14,
"assists": 9
}
}
]
}
]
}
5. Yanıt Alanları Açıklaması
Alan Açıklama player.id Oyuncunun benzersiz kimlik numarası. player.name Oyuncunun adı. statistics.team.name Oyuncunun oynadığı takımın adı. statistics.league.name Oyuncunun oynadığı ligin adı. statistics.games.appearences Oyuncunun toplam maç sayısı. statistics.goals.assists Oyuncunun yaptığı asist sayısı. 6. Python Betiği: Asist Liderlerini Çekme ve Arayüz
Kod:
import requests
from prettytable import PrettyTable
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
def fetch_top_assists(league_id, season):
url = f"{BASE_URL}players/topassists?season={season}&league={league_id}"
response = requests.get(url, headers=HEADERS)
if response.status_code == 200:
data = response.json()
display_top_assists(data)
else:
print("API Hatası:", response.status_code)
def display_top_assists(data):
table = PrettyTable()
table.field_names = ["Oyuncu", "Takım", "Lig", "Asistler", "Oynadığı Maç"]
for assist in data["response"]:
player = assist["player"]
stats = assist["statistics"][0]
table.add_row([
player["name"],
stats["team"]["name"],
stats["league"]["name"],
stats["goals"]["assists"],
stats["games"]["appearences"]
])
print(table)
# Kullanım
fetch_top_assists(league_id=61, season=2020)
7. Stratejik Önemi
Performans Değerlendirme
●
Oyuncuların asist performanslarını analiz ederek takım içindeki yaratıcı oyuncuları belirleyebilirsiniz.
Taktiksel Planlama
●
Asist yapma yetenekleriyle öne çıkan oyunculara yönelik özel taktikler geliştirebilirsiniz.
Fantezi Lig Avantajları
●
Fantezi liglerde yüksek asist katkısı sağlayabilecek oyuncuları seçmek için ideal.
Transfer Planlaması
●
Asist liderleri, transfer piyasasında aranan oyuncular arasında öne çıkar.
8. Özet
●
Top Assists endpoint, oyuncuların pas ve yaratıcı katkılarını analiz etmek için kullanılır.
●
Kod örneği, verilerin kolayca çekilmesini ve PrettyTable ile görselleştirilmesini sağlar.
●
Uygulama Alanları, teknik direktörler, analistler ve futbolseverler için geniş bir yelpazeye sahiptir.
🌟 Bu bilgilerle analizlerinizi güçlendirebilir, karar alma süreçlerinizi hızlandırabilirsiniz!

--------------------------------------------------------------------------------
enskorer oyuncu
Top Scorers Endpoint: Detaylı Açıklama ve Uygulama
1. Tanım ve Kullanım Amacı
Bu endpoint, belirli bir lig veya kupa için sezon bazında en iyi 20 golcüyü döner. Bu veriler, gol atan oyuncuların performansını karşılaştırmak ve analiz etmek için kullanılır.
Kullanım Alanları
●
Performans Karşılaştırması: Oyuncuların gol, asist, dakika ve diğer istatistiklerini karşılaştırarak analiz yapma.
●
Taktiksel Planlama: En iyi golcüler üzerinden takım planlaması ve analiz.
●
Fantezi Lig Stratejileri: Gol ve asist bazlı oyuncu seçiminde yardımcı.
2. Güncelleme Sıklığı
●
Haftada birkaç kez güncellenir. Böylece oyuncu performansı dinamik olarak takip edilebilir.
3. Önerilen Çağrı Limiti
●
Günlük 1 çağrı, oyuncu performanslarının çok sık değişmemesi nedeniyle yeterlidir.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "players/topscorers",
"parameters": {
"league": "61",
"season": "2018"
},
"errors": [],
"results": 20,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"player": {
"id": 278,
"name": "K. Mbappé",
"firstname": "Kylian",
"lastname": "Mbappé Lottin",
"age": 22,
"birth": {
"date": "1998-12-20",
"place": "Paris",
"country": "France"
},
"nationality": "France",
"height": "178 cm",
"weight": "73 kg",
"injured": false,
"photo": "https://media.api-sports.io/football/players/278.png"
},
"statistics": [
{
"team": {
"id": 85,
"name": "Paris Saint Germain",
"logo": "https://media.api-sports.io/football/teams/85.png"
},
"league": {
"id": 61,
"name": "Ligue 1",
"country": "France",
"logo": "https://media.api-sports.io/football/leagues/61.png",
"flag": "https://media.api-sports.io/flags/fr.svg",
"season": 2018
},
"goals": {
"total": 33,
"assists": 7
}
}
]
}
]
}
5. Yanıt Alanları Açıklaması
Alan Açıklama player.id Oyuncunun benzersiz kimlik numarası. player.name Oyuncunun tam adı. statistics.goals.total Oyuncunun attığı toplam gol sayısı. statistics.goals.assists Oyuncunun yaptığı asist sayısı. statistics.team.name Oyuncunun oynadığı takımın adı. statistics.league.name Oyuncunun oynadığı ligin adı. 6. Python Betiği: Gol Kralları Verisini Çekme ve Arayüz Oluşturma
Kod:
import requests
from prettytable import PrettyTable
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
def fetch_top_scorers(league_id, season):
url = f"{BASE_URL}players/topscorers?season={season}&league={league_id}"
response = requests.get(url, headers=HEADERS)
if response.status_code == 200:
data = response.json()
display_top_scorers(data)
else:
print("API Hatası:", response.status_code)
def display_top_scorers(data):
table = PrettyTable()
table.field_names = ["Oyuncu", "Takım", "Lig", "Goller", "Asistler"]
for scorer in data["response"]:
player = scorer["player"]
stats = scorer["statistics"][0]
table.add_row([
player["name"],
stats["team"]["name"],
stats["league"]["name"],
stats["goals"]["total"],
stats["goals"]["assists"]
])
print(table)
# Kullanım
fetch_top_scorers(league_id=61, season=2018)
7. Stratejik Önemi
Performans Analizi
●
Oyuncuların gol, asist ve diğer istatistiklerini analiz ederek bir oyuncunun gerçek katkısını ölçebilirsiniz.
Takım Planlaması
●
En iyi golcülerden biriyle sözleşme yapmayı düşünen takımlar için bu veri hayati öneme sahiptir.
Fantezi Lig Stratejileri
●
Fantezi liglerde yüksek puan getirecek oyuncuların seçimi için ideal bir kaynak.
Kariyer Gelişimi
●
Oyuncuların kariyerindeki sezonlara göre performans farklarını analiz edebilirsiniz.
8. Özet
●
Bu endpoint, lig ve sezon bazında en iyi golcüler hakkında kapsamlı bilgiler sunar.
●
Python betiğiyle kolayca veri çekebilir ve PrettyTable kullanarak çıktıyı düzenli bir şekilde sunabilirsiniz.
●
Analizler, futbol istatistiklerine dayalı veri odaklı kararlar almanıza yardımcı olabilir.
🌟 Bu bilgiler, analizlerinizi daha stratejik ve verimli hale getirebilir.

--------------------------------------------------------------------------------
Oyuncukariyeri
Players/Teams Endpoint: Detaylı Analiz ve Kullanım Rehberi
1. Tanım ve Kullanım Amacı
Bu endpoint, bir oyuncunun kariyerindeki takımların ve bu takımlarda oynadığı sezonların listesini döner. Oyuncunun transfer geçmişini ve kariyer rotasını detaylı bir şekilde analiz etmek için kullanılabilir.
Kullanım Alanları
●
Kariyer Takibi: Oyuncunun hangi takımlarda ve hangi sezonlarda oynadığını görmek.
●
Kapsamlı İstatistikler: Takım bazlı veya sezon bazlı performans analizi için zemin hazırlamak.
●
Tarihsel Analiz: Bir oyuncunun kariyer gelişimini sezonlar boyunca incelemek.
2. Güncelleme Sıklığı
●
Haftada birkaç kez güncellenir. Bu, oyuncu transferleri veya güncellenen verilerin hızlı bir şekilde yansıtılmasını sağlar.
3. Önerilen Çağrı Limiti
●
Haftada 1 çağrı, genellikle oyuncuların geçmiş takımları ve sezon bilgileri nadiren değiştiğinden yeterlidir.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "players/teams",
"parameters": {
"player": "276"
},
"errors": [],
"results": 8,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"team": {
"id": 6,
"name": "Brazil",
"logo": "https://media.api-sports.io/football/teams/6.png"
},
"seasons": [
2026,
2023,
2022,
2021,
2019,
2018,
2017,
2016,
2015,
2014,
2013,
2012,
2011,
2010
]
}
]
}
5. Yanıt Alanları Açıklaması
Alan Açıklama team.id Takımın benzersiz kimlik numarası. team.name Takımın adı. team.logo Takımın logosunun URL’si. seasons Oyuncunun ilgili takımda oynadığı sezonların listesi. 6. Kullanım Örnekleri
A) Belirli Bir Oyuncunun Tüm Takımlarını Çekme
GET /players/teams?player=276
●
Sonuç: Neymar'ın oynadığı tüm takımlar ve oynadığı sezonlar listelenir.
B) Oyuncunun Sezon Bazlı Transfer Analizi
Neymar'ın kariyer rotasını analiz ederek hangi yıllarda hangi takımlarda oynadığını görselleştirebilirsiniz. Örneğin:
●
2009-2012: Santos
●
2013-2016: Barcelona
●
2017-2022: Paris Saint-Germain
●
2023-2024: Al-Hilal Saudi FC
7. Python Betiği: Oyuncunun Takımlarını ve Sezonlarını Çekme
Kod:
import requests
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
def fetch_player_teams(player_id):
url = f"{BASE_URL}players/teams?player={player_id}"
response = requests.get(url, headers=HEADERS)
if response.status_code == 200:
data = response.json()
print(f"Player Teams and Seasons for Player ID {player_id}:\n")
for team_data in data["response"]:
team = team_data["team"]
seasons = team_data["seasons"]
print(f"Team: {team['name']} ({team['id']})")
print(f"Seasons: {', '.join(map(str, seasons))}")
print("---")
else:
print("API Hatası:", response.status_code)
# Kullanım
fetch_player_teams(player_id=276)
8. Stratejik Önemi
1.
Kariyer Takibi:
●
Oyuncuların kariyer boyunca hangi takımlarda oynadığını ve hangi sezonlarda forma giydiğini görerek oyuncunun kariyerinin genel rotasını anlamak.
●
Özellikle transfer analistleri ve scout ekipleri için kritik.
1.
Takım Analizi:
●
Bir oyuncunun bir takımda hangi sezonlarda bulunduğunu bilmek, takımın tarihçesi ve performansını analiz etmek için faydalıdır.
1.
Transfer Stratejileri:
●
Oyuncunun önceki takımlarında geçirdiği süreyi ve oynadığı sezonları bilmek, transferlerde oyuncunun geçmiş performansını değerlendirmek için gereklidir.
1.
Veri Görselleştirme:
●
Oyuncuların kariyer yolculuklarını görselleştirmek için kullanılabilir. Örneğin, yıllara göre bir zaman çizelgesi oluşturmak.
9. Özet
●
Bu endpoint, bir oyuncunun kariyerindeki tüm takımları ve bu takımlarda oynadığı sezonları listeler.
●
Bu veriler, hem bireysel hem de takım bazlı analizlerde kullanılabilir.
●
Python betiğiyle bu veriler kolayca çekilip işlenebilir.
Bu endpoint, oyuncu kariyerlerinin detaylı analizini yapmak isteyen analistler ve futbol severler için oldukça stratejik bir araçtır. 🌟

--------------------------------------------------------------------------------
oyuncuistatistiği2
Statistics Endpoint: Detaylı Analiz ve Kullanım Rehberi
1. Tanım ve Kullanım Amacı
Statistics Endpoint, oyuncuların profillerine ve istatistiklerine ulaşmak için kullanılan bir araçtır. Bu endpoint, belirli bir oyuncunun belirli bir sezon, takım ve ligdeki performans verilerini içerir. İstatistikler, oyuncunun transfer geçmişine göre birden fazla takım için bulunabilir. Ayrıca, bu endpoint, oyuncunun performansına göre hesaplanan bir rating (puanlama) değeri de sağlar.
Kullanım Alanları
●
Performans Analizi: Oyuncuların sezonluk ya da maç bazlı performanslarını analiz etme.
●
Transfer Verisi: Oyuncunun birden fazla takımda oynadığı durumlarda tüm verilerine erişim.
●
Rekabetçi Analiz: Aynı pozisyondaki diğer oyuncularla karşılaştırma.
●
Takım Analizi: Bir takımın kadrosundaki oyuncuların istatistiklerini çekme.
2. Güncelleme Sıklığı
●
Haftada birkaç kez güncellenir. Bu, oyuncuların istatistiklerinin düzenli olarak güncel kalmasını sağlar.
3. Önerilen Çağrı Limiti
●
Günlük 1 çağrı, genel sezon ve oyuncu verilerini düzenli olarak almak için yeterlidir.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "players/squads",
"parameters": {
"team": "33"
},
"errors": [],
"results": 1,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"team": {
"id": 33,
"name": "Manchester United",
"logo": "https://media.api-sports.io/football/teams/33.png"
},
"players": [
{
"id": 20319,
"name": "N. Bishop",
"age": 22,
"number": 30,
"position": "Goalkeeper",
"photo": "https://media.api-sports.io/football/players/20319.png"
}
]
}
]
}
5. Yanıt Alanları Açıklaması
Alan Açıklama player.id Oyuncunun benzersiz kimlik numarası. player.name Oyuncunun tam adı. player.position Oyuncunun pozisyonu (ör. "Goalkeeper", "Defender"). team.id Takımın benzersiz kimlik numarası. team.name Takımın adı. team.logo Takım logosunun URL’si. photo Oyuncunun fotoğrafının URL’si. age Oyuncunun yaşı. number Oyuncunun forma numarası. 6. Pagination (Sayfalama)
●
Endpoint, 20 sonuç döner. Daha fazla veri almak için page parametresi kullanılır.
●
Örnek:
●
GET /players/squads?team=33&page=1
●
GET /players/squads?team=33&page=2
7. Kullanım Örnekleri
A) Belirli Bir Oyuncunun Verilerini Çekme
GET /players/statistics?id=20319&team=33&league=39&season=2023
●
Sonuç: Manchester United oyuncusu N. Bishop’un Premier League 2023 sezonundaki verileri döner.
B) Belirli Bir Takımın Tüm Oyuncularını Listeleme
GET /players/squads?team=33
●
Sonuç: Manchester United’ın mevcut kadrosu döner.
C) İsim Bazlı Oyuncu Arama
GET /players/statistics?search=Fernandes&league=39
●
Sonuç: Premier League’de "Fernandes" isimli tüm oyuncuların verilerini döner.
8. Rating Değeri
Rating, bir oyuncunun performansını ölçen bir değerdir. Bu, oyuncunun pozisyonu ve diğer oyuncularla karşılaştırmalı performansı dikkate alınarak hesaplanır.
●
Algoritmalar:
●
Hücum oyuncuları için: Goller, asistler, şut yüzdesi gibi metrikler.
●
Savunma oyuncuları için: Müdahaleler, top çalmalar, rakip şut engellemeleri gibi metrikler.
●
Kaleciler için: Kurtarış yüzdesi, gol yememe oranı gibi metrikler.
9. Python Betiği: Oyuncu İstatistiklerini Çekme
Kod:
import requests
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
def fetch_player_statistics(team_id, league_id, season):
url = f"{BASE_URL}players/statistics?team={team_id}&league={league_id}&season={season}"
response = requests.get(url, headers=HEADERS)
if response.status_code == 200:
data = response.json()
for player in data.get("response", []):
print(f"Player: {player['player']['name']}")
print(f"Position: {player['statistics'][0]['games']['position']}")
print(f"Rating: {player['statistics'][0]['games']['rating']}")
print("---")
else:
print("API Hatası:", response.status_code)
# Kullanım
fetch_player_statistics(team_id=33, league_id=39, season=2023)
10. Stratejik Önemi
1.
Dinamik Performans Analizi:
●
Sezonluk ya da maç bazlı istatistiklerle oyuncu performansı kolayca analiz edilebilir.
1.
Kapsamlı Veri Entegrasyonu:
●
Bu endpoint, oyuncu istatistikleriyle ilgili diğer endpointlerle birleştirilerek geniş veri setleri oluşturulabilir.
1.
Karşılaştırmalı Analiz:
●
Pozisyon bazında farklı oyuncuların karşılaştırılmasıyla detaylı raporlar hazırlanabilir.
1.
Scout ve Transfer Planlaması:
●
Oyuncuların performans verilerine dayanarak transfer ya da scout raporları hazırlanabilir.
11. Özet
●
Statistics Endpoint, oyuncuların sezonluk ve maç bazlı istatistiklerine erişim sağlar.
●
Rating sistemi, oyuncuların performansını objektif bir şekilde değerlendirir.
●
Python betiğiyle bu veriler efektif bir şekilde kullanılabilir.
Bu endpoint, profesyonel analizler ve derinlemesine raporlamalar için kritik bir öneme sahiptir. 🚀

--------------------------------------------------------------------------------
Oyuncuprofilitemelsorgu
Profiles Endpoint Analizi ve Detaylı Raporu
1. Tanım ve Kullanım Alanı
Profiles Endpoint, futbol oyuncularının profilleriyle ilgili kapsamlı bilgi sağlar. Oyuncuların temel biyografik bilgileri, fiziksel özellikleri, pozisyonları ve fotoğrafları gibi detaylar içerir.
Bu endpoint, özellikle oyuncuların bireysel profillerini görüntülemek, istatistiksel verileri bağlamak ve oyuncu aramaları yapmak için kullanılır.
Kullanım Alanları:
●
Oyuncu Bilgisi Görüntüleme: Biyografi, fiziksel özellikler ve pozisyon bilgisi.
●
Arama ve Filtreleme: Soyadı veya ID’ye göre oyuncu arama.
●
Veritabanı Güncelleme: Oyuncu bilgilerini düzenli olarak çekip bir veritabanını güncel tutma.
2. Güncelleme Sıklığı
●
Haftada birkaç kez güncellenir. Bu, oyuncuların yeni bilgileri (transfer, forma numarası değişiklikleri vb.) güncel şekilde sunar.
3. Önerilen Çağrı Limiti
●
Haftada 1 çağrı, tüm oyuncu bilgilerini almak için yeterlidir.
●
Dinamik bir liste oluşturulması gerekiyorsa, pagination (sayfalama) kullanılarak tüm sonuçlar çekilebilir.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "players/profiles",
"parameters": {
"player": "276"
},
"errors": [],
"results": 1,
"paging": {
"current": 1,
"total": 1
},
"response": [
{
"player": {
"id": 276,
"name": "Neymar",
"firstname": "Neymar",
"lastname": "da Silva Santos Júnior",
"age": 32,
"birth": {
"date": "1992-02-05",
"place": "Mogi das Cruzes",
"country": "Brazil"
},
"nationality": "Brazil",
"height": "175 cm",
"weight": "68 kg",
"number": 10,
"position": "Attacker",
"photo": "https://media.api-sports.io/football/players/276.png"
}
}
]
}
5. Çıktı Detayları
Yanıt Alanları Açıklaması:
Alan Açıklama player.id Oyuncunun benzersiz kimlik numarası. player.name Oyuncunun tam adı. player.age Oyuncunun yaşı. player.birth Doğum tarihi, yeri ve ülkesi bilgisi. player.nationality Oyuncunun uyruk bilgisi. player.height Oyuncunun boyu. player.weight Oyuncunun kilosu. player.number Oyuncunun forma numarası. player.position Oyuncunun pozisyonu (ör. "Attacker", "Midfielder"). player.photo Oyuncunun fotoğraf URL’si. 6. Pagination (Sayfalama)
●
Endpoint, bir sayfada 250 oyuncu döner. Daha fazla oyuncu bilgisi almak için page parametresi kullanılır.
●
Örnek: İlk 500 oyuncuyu almak için 2 sayfa sorgulanır:
●
GET /players/profiles?page=1
●
GET /players/profiles?page=2
7. Kullanım Örnekleri
A) Belirli Bir Oyuncunun Bilgilerini Çekme
GET /players/profiles?player=276
●
Sonuç: Neymar'ın detaylı profili döner.
B) Oyuncuları Soyadına Göre Arama
GET /players/profiles?search=Messi
●
Sonuç: Soyadında "Messi" geçen tüm oyuncuları döner.
C) Tüm Oyuncu Bilgilerini Çekme
GET /players/profiles?page=1
GET /players/profiles?page=2
...
●
Sonuç: Pagination kullanılarak tüm oyuncular listelenir.
8. Python Betiği: Oyuncu Profilleri Çekme
Bu betik, oyuncu profillerini kullanıcı dostu bir arayüzle görüntüler.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QWidget
)
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
class ProfilesApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Oyuncu Profilleri")
self.resize(600, 400)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Başlık
layout.addWidget(QLabel("Oyuncu Profilleri:"))
# Tablo
self.table = QTableWidget(0, 4)
self.table.setHorizontalHeaderLabels(["ID", "Ad", "Pozisyon", "Yaş"])
layout.addWidget(self.table)
self.fetch_button = QPushButton("Profilleri Getir")
self.fetch_button.clicked.connect(self.fetch_profiles)
layout.addWidget(self.fetch_button)
central_widget.setLayout(layout)
def fetch_profiles(self):
url = f"{BASE_URL}players/profiles?page=1"
response = requests.get(url, headers=HEADERS)
data = response.json()["response"]
self.update_table(data)
def update_table(self, players):
self.table.setRowCount(0)
for player in players:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(str(player["player"]["id"])))
self.table.setItem(row, 1, QTableWidgetItem(player["player"]["name"]))
self.table.setItem(row, 2, QTableWidgetItem(player["player"]["position"]))
self.table.setItem(row, 3, QTableWidgetItem(str(player["player"]["age"])))
if __name__ == "__main__":
app = QApplication(sys.argv)
window = ProfilesApp()
window.show()
sys.exit(app.exec_())
9. Stratejik Önemi
1.
Dinamik Oyuncu Bilgisi: Oyuncuların sürekli değişen bilgilerine ulaşmak için en temel kaynaktır.
2.
Arama Yeteneği: İsim bazlı arama yaparak spesifik oyuncuları hızlıca bulma imkanı sağlar.
3.
Veri Entegrasyonu: Diğer endpointlerle birleştirilerek detaylı analiz ve karşılaştırma yapılabilir.
10. Özet
●
Profiles Endpoint, oyuncuların biyografik ve fiziksel özelliklerine erişim sağlar.
●
Pagination sistemi, büyük verisetlerini yönetmek için önemlidir.
●
Python betiği ile, oyuncu profilleri kullanıcı dostu bir arayüzle kolayca erişilebilir hale getirilmiştir.
Bu endpoint, hem bireysel hem de geniş çaplı futbol veri projeleri için kritik bir yapı taşıdır. 🚀

--------------------------------------------------------------------------------
Oyuncunun kariyer gelişiminin sezona göre analiz edilmesi.
Seasons Endpoint Analizi ve Detaylı Raporu
1. Tanım ve Kullanım Alanı
●
Seasons Endpoint, bir oyuncunun istatistiklerinin bulunduğu tüm sezonların listesini döner.
●
Bu endpoint, geçmiş yıllara ait istatistiksel verilerin analizi ve karşılaştırılması için kullanılır.
●
Örnek Kullanımlar:
●
Kariyer Analizi: Oyuncunun kariyer gelişiminin sezona göre analiz edilmesi.
●
Geçmiş Performans Karşılaştırmaları: Belirli sezonlarda oyuncunun performans trendlerini görme.
2. Güncelleme Sıklığı
●
Günlük olarak güncellenir. Yeni sezon verileri eklendikçe veya mevcut veriler güncellendikçe bu endpointten alınabilir.
3. Önerilen Çağrı Limiti
●
Günde 1 çağrı, gereksiz API kullanımını azaltmak için yeterlidir.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "players/seasons",
"parameters": [],
"errors": [],
"results": 35,
"paging": {
"current": 1,
"total": 1
},
"response": [
1966, 1982, 1986, 1990, 1991, 1992, 1993, 1994, 1995,
1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013,
2014, 2015, 2016, 2017, 2018, 2019, 2020, 2022
]
}
5. Çıktı Detayları
●
"response" Dizisi:
●
Her bir değer, bir sezonu temsil eder.
●
Sezonlar, istatistiklerin bulunduğu tüm yılları içerir.
●
Örnek: 1986, 1990, 2020 gibi değerler, bu yıllarda istatistik verilerinin mevcut olduğunu belirtir.
Yanıt Alanları:
Alan Açıklama get Çağrılan endpoint ismini belirtir. parameters Endpointte kullanılan parametreler. errors Hatalar dizisi (boş olması, işlemde hata olmadığını gösterir). results Bulunan sezon sayısını belirtir. response Oyuncu istatistiklerinin bulunduğu tüm sezonların listesidir. 6. Kullanım Örnekleri
A) Oyuncu Performansının Sezonsal Analizi
●
Kullanıcılar, oyuncunun performansını sezonsal olarak analiz etmek istiyorsa, bu endpoint ile istatistiklerin hangi sezonlarda mevcut olduğunu öğrenebilir.
B) Tarihsel Kapsam Analizi
●
Bu endpoint, bir veri setinin tarihsel derinliğini görmek için kullanılabilir. Örneğin, 1966’dan itibaren istatistik verileri olan bir oyuncunun kapsamlı bir kariyer analizi yapılabilir.
C) Modern ve Tarihsel Futbol Karşılaştırmaları
●
Modern futbol (örneğin 2010 sonrası) ile geçmiş futbol (örneğin 1980’ler) arasındaki performans trendlerini değerlendirmek için kullanılabilir.
7. Seasons Endpoint ile Diğer Endpointlerin Karşılaştırması
Özellik Seasons Players Statistics Injuries Amaç Mevcut sezonların listesini döner Oyuncu istatistiklerini döner Oyuncuların sakatlık durumu Parametreler player (opsiyonel) player, fixture, team team, fixture, date Güncelleme Sıklığı Günlük Dakikada bir 4 saatte bir Sonuç Çıktısı Sezonlar İstatistiksel veriler Sakatlık ve ceza durumu 8. Python Betiği: Tüm Mevcut Sezonları Listeleme
Bu betik, bir oyuncunun istatistiklerinin mevcut olduğu sezonları listelemek için kullanılır.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QWidget
)
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
class SeasonsApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Mevcut Sezonlar")
self.resize(400, 300)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Başlık
layout.addWidget(QLabel("Oyuncunun istatistiklerinin bulunduğu sezonlar:"))
# Tablo
self.table = QTableWidget(0, 1)
self.table.setHorizontalHeaderLabels(["Sezonlar"])
layout.addWidget(self.table)
self.fetch_button = QPushButton("Sezonları Getir")
self.fetch_button.clicked.connect(self.fetch_seasons)
layout.addWidget(self.fetch_button)
central_widget.setLayout(layout)
def fetch_seasons(self):
url = f"{BASE_URL}players/seasons"
response = requests.get(url, headers=HEADERS)
data = response.json()["response"]
self.update_table(data)
def update_table(self, seasons):
self.table.setRowCount(0)
for season in seasons:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(str(season)))
if __name__ == "__main__":
app = QApplication(sys.argv)
window = SeasonsApp()
window.show()
sys.exit(app.exec_())
9. Stratejik Önemi
●
Veri Derinliği: Endpoint, oyuncuların tüm kariyerini kapsayan istatistikleri analiz etmeye olanak tanır.
●
Karşılaştırmalı Analizler: Farklı sezonlarda oyuncuların performans trendlerini belirlemek için kullanılabilir.
●
Kariyer Yolculuğu: Genç yeteneklerin gelişimini veya deneyimli oyuncuların kariyer sonu performanslarını değerlendirmek için idealdir.
10. Özet
●
Seasons Endpoint, tarihsel verilerin analizinde önemli bir araçtır.
●
Kullanıcılar, oyuncuların uzun vadeli performansını anlamak ve kariyerlerini karşılaştırmak için bu veriyi stratejik olarak kullanabilir.
●
Python betiği ile kullanıcı dostu bir arayüz oluşturularak sezon bilgileri kolayca erişilebilir hale getirilmiştir.
Bu araç, futbol analistleri, veri bilimciler ve tarihsel futbol verilerini sevenler için mükemmel bir çözüm sunar. 🚀

--------------------------------------------------------------------------------
istatistikselmaçsonuçtahminigoltarafvs....
Predictions Endpoint Analizi ve Detaylı Raporu
1. Tanım ve Kullanım Alanı
●
Predictions Endpoint: Belirli bir maç (fixture) için tahminleri getirir.
●
Tahminler, istatistiksel analiz, son maçlar, takım performansı, oyuncu verileri ve Poisson dağılımı gibi algoritmalarla oluşturulur.
●
Not: Bahis oranları kullanılmaz. Tahminler tamamen verilere dayalıdır.
2. Kullanılabilir Tahminler
1.
Match Winner: Maçı kazanma ihtimali en yüksek olan takımın ID’si ve ismi.
2.
Win or Draw: Eğer true ise, belirtilen takım maçı kazanabilir veya berabere kalabilir.
3.
Under/Over Goals:
●
Toplam gol tahmini: -1.5, -2.5, -3.5, +1.5, vb.
●
Örnek: -1.5 toplam 1 gol veya daha az olacağını belirtir.
1.
Goals Home / Away:
●
Ev sahibi ve deplasman takımının gol tahminleri (-1.5, -2.5).
1.
Advice: Maç sonucu ve gol tahminleri hakkında kombinasyon önerisi (örneğin: "Deportivo Santani veya berabere ve -3.5 gol").
2.
Yüzde Dağılımları: Ev sahibi, deplasman ve beraberlik ihtimalleri yüzdesel olarak verilir.
3. Güncelleme Sıklığı
●
Sıklık: Saatlik güncellenir.
●
Önerilen Çağrı Limiti:
●
Devam eden maçlar: Saatte 1 çağrı.
●
Diğer maçlar: Günde 1 çağrı.
4. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "predictions",
"parameters": {
"fixture": "198772"
},
"results": 1,
"response": [
{
"predictions": {
"winner": {
"id": 1189,
"name": "Deportivo Santani",
"comment": "Win or draw"
},
"win_or_draw": true,
"under_over": "-3.5",
"goals": {
"home": "-2.5",
"away": "-1.5"
},
"advice": "Combo Double chance : Deportivo Santani or draw and -3.5 goals",
"percent": {
"home": "45%",
"draw": "45%",
"away": "10%"
}
}
}
]
}
5. Algoritmalar ve Çıktıların Anlamı
Poisson Dağılımı:
●
Futbolda skor tahmini yapmak için kullanılan olasılık teorisine dayalı bir yöntemdir.
●
Ev sahibi ve deplasman takımının ortalama gol sayılarına dayalı olarak bir skor tahmini yapılır.
Takım Karşılaştırmaları:
●
Form, hücum (att), savunma (defans) performanslarına göre yüzdesel karşılaştırmalar sunulur.
●
H2H (Head-to-Head): Takımların geçmiş maçlarının analizleri yapılır.
Örnek Çıktı Açıklaması:
●
"Match Winner": Deportivo Santani'nin kazanma ihtimali yüksek.
●
"Win or Draw": Deportivo Santani maçı kazanabilir veya berabere kalabilir.
●
"Under 3.5 Goals": Toplam gol sayısı 3.5’in altında olacak.
●
"Goals Home/Away": Ev sahibi en fazla 2, deplasman en fazla 1 gol atabilir.
●
"Advice": Çifte şans önerisi ve gol tahmini kombinasyonu.
6. Predictions Endpoint ile Diğer Endpointlerin Karşılaştırması
Özellik Predictions Players Statistics Lineups Amaç Maç sonucu ve gol tahminleri Oyuncu performans istatistikleri Maç kadrosu ve formasyon bilgileri Güncelleme Sıklığı Saatlik 1 dakikada bir 15 dakikada bir Veri Türü Tahminler ve yüzdelik dağılımlar Şut, pas, savunma istatistikleri Oyuncu listesi ve formasyon Parametreler fixture fixture, team fixture, team, player Sonuç Çıktısı Kazanma olasılığı, gol tahminleri Oyuncu istatistik detayları Başlangıç 11'i ve yedekler 7. Python Betiği: Maç Tahminlerini Gösterme
Bu uygulama, bir maçın tahminlerini görüntüleyen basit bir arayüz sunar.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QWidget
)
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
class PredictionsApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Maç Tahminleri")
self.resize(600, 400)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
layout.addWidget(QLabel("Maç ID (Fixture):"))
self.fixture_input = QLineEdit()
layout.addWidget(self.fixture_input)
self.fetch_button = QPushButton("Tahminleri Getir")
self.fetch_button.clicked.connect(self.fetch_predictions)
layout.addWidget(self.fetch_button)
# Tablo
self.table = QTableWidget(0, 2)
self.table.setHorizontalHeaderLabels(["Özellik", "Değer"])
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_predictions(self):
fixture_id = self.fixture_input.text()
if not fixture_id.isdigit():
QLabel("Geçerli bir Maç ID girin!")
return
url = f"{BASE_URL}predictions?fixture={fixture_id}"
response = requests.get(url, headers=HEADERS)
data = response.json()["response"][0]["predictions"]
self.update_table(data)
def update_table(self, predictions):
self.table.setRowCount(0)
for key, value in predictions.items():
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(key.capitalize()))
self.table.setItem(row, 1, QTableWidgetItem(str(value)))
if __name__ == "__main__":
app = QApplication(sys.argv)
window = PredictionsApp()
window.show()
sys.exit(app.exec_())
8. Özet
●
Predictions Endpoint futbol analizleri için stratejik bir araçtır.
●
Gerçek zamanlı veri analizi, takım karşılaştırmaları ve tahmin algoritmaları sayesinde:
●
Bahis analizleri,
●
Teknik direktör planlamaları,
●
Maç öncesi yorumlar için kullanılır.
Bu uygulama, doğru maç tahminleri yapmak isteyen herkes için oldukça güçlü bir çözümdür. 🚀

--------------------------------------------------------------------------------
Oyuncusakatlıksorgulaması
Injuries Endpoint Analizi ve Raporu
1. Tanım ve Kullanım Alanı
●
Injuries Endpoint: Maçlara katılamayan veya katılımı şüpheli olan oyuncuların listesini getirir.
●
İçerik:
●
Oyuncunun adı, ID'si, resmi.
●
Katılmama nedeni (sakatlık, hastalık, ceza vb.).
●
Maç, takım ve lig bilgileri.
2. Kullanım Özellikleri
●
Veri Kapsamı:
●
2 tür veri:
●
Missing Fixture: Oyuncu kesin olarak katılamıyor.
●
Questionable: Oyuncunun durumu belirsiz.
●
Kullanılabilir Parametreler:
●
league: Lig ID'si.
●
season: Sezon yılı.
●
fixture: Maç ID'si.
●
team: Takım ID'si.
●
player: Oyuncu ID'si.
●
date: Belirli bir tarih (YYYY-MM-DD formatı).
●
ids: Maksimum 20 maç ID'si.
●
timezone: Saat dilimi.
●
Güncelleme Sıklığı: 4 saatte bir.
●
Önerilen Çağrı Limiti: Günde 1 çağrı.
3. API Yanıt Formatı
Örnek JSON Yanıtı:
{
"get": "injuries",
"parameters": {
"fixture": "686314"
},
"results": 13,
"response": [
{
"player": {
"id": 865,
"name": "D. Costa",
"photo": "https://media.api-sports.io/football/players/865.png",
"type": "Missing Fixture",
"reason": "Broken ankle"
},
"team": {
"id": 157,
"name": "Bayern Munich",
"logo": "https://media.api-sports.io/football/teams/157.png"
},
"fixture": {
"id": 686314,
"date": "2021-04-07T19:00:00+00:00"
},
"league": {
"id": 2,
"name": "UEFA Champions League",
"season": 2020
}
}
]
}
4. Analiz: Diğer Endpointlerle Farkı
Özellik Injuries Lineups Players Statistics Amaç Sakat, cezalı oyuncuları getirir Maç kadrosunu listeler Oyuncuların performans detaylarını verir Parametreler league, fixture, team, player fixture fixture, team Veri Türü Oyuncu durumu ve nedeni Kadro, formasyon, yedek oyuncular Şutlar, paslar, performans notu Güncelleme Sıklığı 4 saat 15 dakika 1 dakika 5. Python Betiği: Oyuncu Eksikliklerini Listeleme
Bu uygulama, belirli bir maç için katılamayan veya şüpheli oyuncuları gösteren detaylı bir arayüz oluşturur.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QWidget
)
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
class InjuriesApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Sakat ve Cezalı Oyuncular")
self.resize(800, 600)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
input_layout = QHBoxLayout()
input_layout.addWidget(QLabel("Maç ID (Fixture):"))
self.fixture_input = QLineEdit()
input_layout.addWidget(self.fixture_input)
self.fetch_button = QPushButton("Eksik Oyuncuları Getir")
self.fetch_button.clicked.connect(self.fetch_data)
input_layout.addWidget(self.fetch_button)
layout.addLayout(input_layout)
# Tablo
self.table = QTableWidget(0, 5)
self.table.setHorizontalHeaderLabels(["Takım", "Oyuncu", "Durum", "Nedeni", "Tarih"])
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
fixture_id = self.fixture_input.text()
if not fixture_id.isdigit():
QLabel("Geçerli bir Maç ID girin!")
return
self.fetch_button.setEnabled(False)
try:
url = f"{BASE_URL}injuries?fixture={fixture_id}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
injuries_data = response.json().get("response", [])
self.update_table(injuries_data)
except Exception as e:
print(f"Hata: {e}")
finally:
self.fetch_button.setEnabled(True)
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(item["team"]["name"]))
self.table.setItem(row, 1, QTableWidgetItem(item["player"]["name"]))
self.table.setItem(row, 2, QTableWidgetItem(item["player"]["type"]))
self.table.setItem(row, 3, QTableWidgetItem(item["player"]["reason"]))
self.table.setItem(row, 4, QTableWidgetItem(item["fixture"]["date"]))
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = InjuriesApp()
window.show()
sys.exit(app.exec_())
6. Kullanım Talimatları:
1.
Maç ID (Fixture) girin.
2.
"Eksik Oyuncuları Getir" butonuna tıklayın.
3.
Oyuncu adı, durumu (Missing Fixture/Questionable), nedeni (Sakatlık, ceza) ve maç tarihi ekrana listelenir.
Özellikler:
●
Arayüz: Oyuncuların eksiklik nedenlerini kolay okunabilir bir formatta gösterir.
●
Özelleştirme: Belirli bir takım veya oyuncu ID'sine göre genişletilebilir.
Bu uygulama, maç öncesi analizler için eksik oyuncu bilgilerini detaylı bir şekilde sunar. ⚽ Detaylı veri analizi ve maç hazırlıkları için oldukça kullanışlıdır. 👏

--------------------------------------------------------------------------------
oyuncu istatistiği
Players Statistics Endpoint Analizi ve Raporu
1. Tanım ve Kullanım Alanı:
●
Players Statistics: Bir maça (fixture) ait oyuncuların istatistiklerini getirir.
●
İçerik:
●
Oyuncu adı, forma numarası, pozisyonu.
●
Maç süresi, performans notu (rating).
●
Pas, şut, gol, asist gibi detaylı istatistikler.
●
Kartlar, penaltı bilgileri ve top kayıpları.
2. API Özellikleri:
●
Güncelleme Sıklığı: Her dakika.
●
Önerilen Çağrı Limiti:
●
Maç sırasında: Dakikada 1 çağrı.
●
Normal günlerde: Günde 1 çağrı.
●
URL: https://v3.football.api-sports.io/fixtures/players
3. Gerekli Parametreler:
●
fixture: Zorunlu. Maç ID'si.
●
Opsiyonel Parametreler:
●
team: Takım ID'si.
4. API Yanıt Formatı:
●
team: Takım bilgisi (ad, ID, logo).
●
players: Oyuncuların detaylı istatistikleri.
●
Önemli İstatistikler:
●
games: Oynama süresi, forma numarası, pozisyon, kaptanlık.
●
shots: Toplam şut ve isabetli şut.
●
goals: Gol sayısı, asist, yediği gol.
●
passes: Toplam pas, kilit pas, pas yüzdesi.
●
tackles: Top çalma, bloklar, araya girme.
●
cards: Sarı ve kırmızı kart sayısı.
●
penalty: Penaltı verileri (atılan, kaçırılan).
5. Örnek Yanıt:
{
"team": {
"id": 2284,
"name": "Monarcas",
"logo": "https://media.api-sports.io/football/teams/2284.png"
},
"players": [
{
"player": {
"id": 35931,
"name": "Sebastián Sosa",
"photo": "https://media.api-sports.io/football/players/35931.png"
},
"statistics": [
{
"games": {"minutes": 90, "number": 13, "position": "G", "rating": "6.3"},
"shots": {"total": 0, "on": 0},
"goals": {"total": null, "conceded": 1, "assists": null, "saves": 0},
"passes": {"total": 17, "key": 0, "accuracy": "68%"},
"cards": {"yellow": 0, "red": 0}
}
]
}
]
}
Players Statistics ile Diğer Endpointlerin Farkı
Özellik Players Statistics Events Amaç Oyuncuların istatistiklerini getirir Maç olaylarını getirir (gol, kart vb.) Parametre fixture, team fixture, team, player, type Veri İçeriği Şutlar, paslar, kartlar, performans notu Goller, kartlar, oyuncu değişiklikleri Güncelleme Sıklığı 1 dakika 15 saniye Kapsam Tüm oyuncuların performans detayları Yalnızca maç içi önemli olaylar Python Betiği: Oyuncu İstatistiklerini Görüntüleme
Bu uygulama, belirli bir maç (fixture) için tüm oyuncuların istatistiklerini listeler. Oyuncu bilgileri, performans notu, pas, şut ve kart bilgilerini içerir.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QWidget
)
from PyQt5.QtCore import QThread, pyqtSignal
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchPlayerStatsThread(QThread):
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, fixture_id):
super().__init__()
self.fixture_id = fixture_id
def run(self):
try:
url = f"{BASE_URL}fixtures/players?fixture={self.fixture_id}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
players_data = response.json().get("response", [])
if not players_data:
self.error.emit("Bu maça ait oyuncu istatistikleri bulunamadı.")
return
data = []
for team in players_data:
team_name = team["team"]["name"]
for player in team["players"]:
stats = player["statistics"][0]
data.append({
"team": team_name,
"player": player["player"]["name"],
"position": stats["games"]["position"],
"minutes": stats["games"]["minutes"],
"rating": stats["games"].get("rating", "N/A"),
"goals": stats["goals"]["total"] or 0,
"passes": stats["passes"]["total"] or 0,
"yellow": stats["cards"]["yellow"] or 0,
"red": stats["cards"]["red"] or 0
})
self.data_ready.emit(data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class PlayerStatsApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Oyuncu İstatistikleri")
self.resize(800, 600)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
input_layout = QHBoxLayout()
input_layout.addWidget(QLabel("Maç ID (Fixture):"))
self.fixture_input = QLineEdit()
input_layout.addWidget(self.fixture_input)
self.fetch_button = QPushButton("İstatistikleri Getir")
self.fetch_button.clicked.connect(self.fetch_data)
input_layout.addWidget(self.fetch_button)
layout.addLayout(input_layout)
# Tablo
self.table = QTableWidget(0, 8)
self.table.setHorizontalHeaderLabels(["Takım", "Oyuncu", "Pozisyon", "Dakika", "Not", "Gol", "Pas", "Sarı Kart", "Kırmızı Kart"])
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
fixture_id = self.fixture_input.text()
if not fixture_id.isdigit():
QLabel("Geçerli bir Maç ID girin!")
return
self.fetch_button.setEnabled(False)
self.thread = FetchPlayerStatsThread(fixture_id)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
for col, value in enumerate(item.values()):
self.table.setItem(row, col, QTableWidgetItem(str(value)))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QLabel(f"Hata: {message}")
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = PlayerStatsApp()
window.show()
sys.exit(app.exec_())
Kullanım Talimatları:
1.
Maç ID (Fixture) girin.
2.
"İstatistikleri Getir" butonuna tıklayın.
3.
Oyuncuların detaylı istatistikleri listelenir.
Bu uygulama, oyuncuların pozisyonları, oynama süresi, performans notu, gol ve kart bilgilerini detaylı bir şekilde sunar. 🎯

--------------------------------------------------------------------------------
maç kadrolarını getiri.
Lineups Endpoint Analizi ve Raporu
1. Tanım ve Kullanım Alanı:
●
Lineups: Bir maça ait takımların diziliş ve oyuncu kadrolarını getirir.
●
İçerik:
●
Formation: Takım dizilişi (örneğin, 4-3-3).
●
Start XI: Maça başlayan 11 oyuncunun bilgileri.
●
Substitutes: Yedek oyuncular.
●
Coach: Teknik direktör bilgisi.
●
Player Positions: Oyuncuların saha içindeki konumları (X:Y koordinatları).
2. API Özellikleri:
●
Güncelleme Sıklığı: Her 15 dakika.
●
Önerilen Çağrı Limiti:
●
Maç sırasında: Dakikada 1 çağrı.
●
Normal günlerde: Günde 1 çağrı.
●
URL: https://v3.football.api-sports.io/fixtures/lineups
3. Gerekli Parametreler:
●
fixture: Zorunlu. Maç ID'si.
●
Opsiyonel Parametreler:
●
team: Takım ID'si.
●
player: Oyuncu ID'si.
●
type: Veri türü.
4. API Yanıt Formatı:
●
response: İki takımın da dizilişi ve oyuncu kadrosunu içerir.
●
Önemli Alanlar:
●
team: Takım adı, ID'si ve logosu.
●
formation: Diziliş şekli.
●
startXI: İlk 11 oyuncularının adı, numarası, pozisyonu ve saha içi konumu.
●
substitutes: Yedek oyuncu bilgileri.
●
coach: Teknik direktör adı ve fotoğrafı.
●
players grid: Oyuncunun saha içindeki konumu (örneğin, "2:3").
5. Örnek Yanıt:
{
"team": {
"id": 50,
"name": "Manchester City"
},
"formation": "4-3-3",
"startXI": [
{
"player": {
"id": 617,
"name": "Ederson",
"number": 31,
"pos": "G",
"grid": "1:1"
}
}
],
"substitutes": [
{
"player": {
"id": 50828,
"name": "Zack Steffen",
"number": 13
}
}
],
"coach": {
"id": 4,
"name": "Guardiola",
"photo": "https://media.api-sports.io/football/coachs/4.png"
}
}
Lineups ve Events Arasındaki Farklar
Özellik Lineups Events Amaç Oyuncu kadrolarını ve dizilişi gösterir Maç içindeki önemli olayları gösterir Veri Güncelleme 15 dakikada bir 15 saniyede bir Anahtar Parametre fixture (zorunlu) fixture, team, player, type Veri İçeriği Diziliş, ilk 11, yedekler, koç Gol, kart, değişiklikler vb. olaylar Kapsam Maç öncesi, sırasında, sonrasında Sadece maç sırasında veya sonrasında Python Betiği: Maç Kadrolarını Görüntüleme
Bu uygulama, belirli bir maç ID'sine ait ilk 11, yedek oyuncuları ve teknik direktörleri listeler.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QWidget
)
from PyQt5.QtCore import QThread, pyqtSignal
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchLineupsThread(QThread):
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, fixture_id):
super().__init__()
self.fixture_id = fixture_id
def run(self):
try:
url = f"{BASE_URL}fixtures/lineups?fixture={self.fixture_id}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
lineups = response.json().get("response", [])
if not lineups:
self.error.emit("Bu maça ait kadro bulunamadı.")
return
data = []
for lineup in lineups:
team = lineup["team"]["name"]
coach = lineup["coach"]["name"]
formation = lineup["formation"]
startXI = [
f"{player['player']['name']} ({player['player']['pos']})"
for player in lineup["startXI"]
]
substitutes = [
player['player']['name']
for player in lineup["substitutes"]
]
data.append({
"team": team,
"coach": coach,
"formation": formation,
"startXI": ", ".join(startXI),
"substitutes": ", ".join(substitutes)
})
self.data_ready.emit(data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class LineupsApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Maç Kadroları")
self.resize(800, 600)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
input_layout = QHBoxLayout()
input_layout.addWidget(QLabel("Maç ID (Fixture):"))
self.fixture_input = QLineEdit()
input_layout.addWidget(self.fixture_input)
self.fetch_button = QPushButton("Kadroları Getir")
self.fetch_button.clicked.connect(self.fetch_data)
input_layout.addWidget(self.fetch_button)
layout.addLayout(input_layout)
# Tablo
self.table = QTableWidget(0, 5)
self.table.setHorizontalHeaderLabels(["Takım", "Koç", "Diziliş", "İlk 11", "Yedekler"])
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
fixture_id = self.fixture_input.text()
if not fixture_id.isdigit():
QLabel("Geçerli bir Maç ID girin!")
return
self.fetch_button.setEnabled(False)
self.thread = FetchLineupsThread(fixture_id)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(item["team"]))
self.table.setItem(row, 1, QTableWidgetItem(item["coach"]))
self.table.setItem(row, 2, QTableWidgetItem(item["formation"]))
self.table.setItem(row, 3, QTableWidgetItem(item["startXI"]))
self.table.setItem(row, 4, QTableWidgetItem(item["substitutes"]))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QLabel(f"Hata: {message}")
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = LineupsApp()
window.show()
sys.exit(app.exec_())
Kullanım Talimatları:
1.
Maç ID (Fixture) girin.
2.
"Kadroları Getir" butonuna tıklayın.
3.
Maça ait diziliş, ilk 11, yedek oyuncular ve teknik direktör bilgileri listelenir.
Bu uygulama, hem ana kadroyu hem de yedek oyuncuları detaylı bir şekilde sunar. 🎯

--------------------------------------------------------------------------------
canlı maç takibi
Events Endpoint Analizi ve Raporu
1. Tanım ve Kullanım Alanı:
●
Events: Belirli bir maça (fixture ID) ait tüm olayları getirir.
●
Olay Türleri:
●
Goal: Normal Gol, Kendi Kalesine Gol, Penaltı, Kaçırılan Penaltı.
●
Card: Sarı Kart, Kırmızı Kart.
●
Subst: Oyuncu Değişikliği.
●
Var: VAR Kararları (Gol iptali, Penaltı onayı).
●
Başlıca Kullanım Alanları:
●
Maç sırasında veya sonrasında tüm önemli olayları görüntülemek.
●
Canlı maçların anlık takibini sağlamak.
2. API Özellikleri:
●
Güncelleme Sıklığı: 15 saniye aralıklarla güncellenir.
●
Önerilen Çağrı Limiti:
●
Canlı Maçlar: Dakikada 1 çağrı.
●
Normal Kullanım: Günde 1 çağrı.
●
URL: https://v3.football.api-sports.io/fixtures/events
3. Gerekli Parametreler:
●
fixture: Zorunlu. Maç ID'si.
●
Opsiyonel Parametreler:
●
team: Takım ID'si.
●
player: Oyuncu ID'si.
●
type: Olay türü (örneğin "Goal", "Card").
4. API Yanıt Formatı:
●
response: Maç içindeki olayların detaylarını içeren liste.
●
Önemli Alanlar:
●
time: Olayın gerçekleştiği dakika.
●
team: Takım bilgisi (adı, ID, logo).
●
player: Olayı gerçekleştiren oyuncu.
●
assist: Asist yapan oyuncu (varsa).
●
type: Olay türü (Goal, Card, Subst, Var).
●
detail: Olayın detayı (örneğin "Normal Goal", "Yellow Card").
●
comments: Ek yorumlar (varsa).
5. Örnek Yanıt:
{
"response": [
{
"time": { "elapsed": 25 },
"team": { "name": "Aldosivi" },
"player": { "name": "F. Andrada" },
"type": "Goal",
"detail": "Normal Goal"
},
{
"time": { "elapsed": 33 },
"team": { "name": "Defensa Y Justicia" },
"player": { "name": "Julio González" },
"type": "Card",
"detail": "Yellow Card"
},
{
"time": { "elapsed": 90 },
"team": { "name": "Aldosivi" },
"player": { "name": "Hernán Burbano" },
"type": "Card",
"detail": "Red Card"
}
]
}
Events Endpoint ile Statistics Endpoint Arasındaki Farklar:
Özellik Statistics Events Amaç Maç içi detaylı istatistikler Maç içindeki önemli olaylar (gol, kart vb.) Veri Güncelleme 1 dakikada bir 15 saniyede bir Anahtar Parametre fixture (zorunlu), team (opsiyonel) fixture (zorunlu), team, player, type Örnek Veri Şutlar, Paslar, Kart Sayıları Gol, Kartlar, Oyuncu Değişiklikleri Kapsam Sayısal verilere odaklı Olay bazlı, oyuncu ve dakika detaylı Python Betiği: Maç Olaylarını Görüntüleme
Bu uygulama, belirli bir maç ID'sine (fixture ID) ait olayları listeleyerek kullanıcıya gösterir.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QProgressBar, QWidget
)
from PyQt5.QtCore import QThread, pyqtSignal
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchEventsThread(QThread):
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, fixture_id):
super().__init__()
self.fixture_id = fixture_id
def run(self):
try:
url = f"{BASE_URL}fixtures/events?fixture={self.fixture_id}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
events = response.json().get("response", [])
if not events:
self.error.emit("Bu maça ait olay bulunamadı.")
return
data = []
for event in events:
data.append({
"time": event["time"]["elapsed"],
"team": event["team"]["name"],
"player": event["player"]["name"],
"type": event["type"],
"detail": event["detail"]
})
self.data_ready.emit(data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class EventsApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Maç Olayları")
self.resize(800, 600)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
input_layout = QHBoxLayout()
input_layout.addWidget(QLabel("Maç ID (Fixture):"))
self.fixture_input = QLineEdit()
input_layout.addWidget(self.fixture_input)
self.fetch_button = QPushButton("Olayları Getir")
self.fetch_button.clicked.connect(self.fetch_data)
input_layout.addWidget(self.fetch_button)
layout.addLayout(input_layout)
# Tablo
self.table = QTableWidget(0, 5)
self.table.setHorizontalHeaderLabels(["Dakika", "Takım", "Oyuncu", "Tür", "Detay"])
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
fixture_id = self.fixture_input.text()
if not fixture_id.isdigit():
QLabel("Geçerli bir Maç ID girin!")
return
self.fetch_button.setEnabled(False)
self.thread = FetchEventsThread(fixture_id)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(str(item["time"])))
self.table.setItem(row, 1, QTableWidgetItem(item["team"]))
self.table.setItem(row, 2, QTableWidgetItem(item["player"]))
self.table.setItem(row, 3, QTableWidgetItem(item["type"]))
self.table.setItem(row, 4, QTableWidgetItem(item["detail"]))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QLabel(f"Hata: {message}")
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = EventsApp()
window.show()
sys.exit(app.exec_())
Kullanım Talimatları:
1.
Maç ID (Fixture) girin.
2.
"Olayları Getir" butonuna tıklayın.
3.
Maçın tüm olayları dakika, takım, oyuncu ve olay türüyle listelenir.
Bu uygulama, maç sırasında veya sonrasında önemli olayları detaylı şekilde görmenizi sağlar. 🎯

--------------------------------------------------------------------------------
Maç istatisikleri
Statistics Endpoint Analizi ve Raporu
1. Tanım ve Kullanım Alanı:
●
Statistics: Belirli bir maça (fixture ID) ait detaylı istatistikleri getirir.
●
Bu endpoint, bir maçın tüm önemli istatistiklerini (şutlar, paslar, fauller, kartlar vb.) görüntülemek için kullanılır.
2. API Özellikleri:
●
Güncelleme Sıklığı: 1 dakika aralıklarla güncellenir.
●
Önerilen Çağrı Limiti:
●
Canlı Maçlar: Dakikada 1 çağrı.
●
Normal Kullanım: Günde 1 çağrı.
●
URL: https://v3.football.api-sports.io/fixtures/statistics
3. Gerekli Parametreler:
●
fixture: Zorunlu. Maç ID'si.
●
Opsiyonel Parametreler:
●
team: Belirli bir takımın ID'si.
●
type: İstatistik türü.
●
half: İlk yarı istatistiklerini eklemek için (true / false).
4. API Yanıt Formatı:
●
response: Takım ve maç istatistiklerini içeren liste.
●
İçindeki Önemli Alanlar:
●
team: Takım bilgileri (adı, ID, logo).
●
statistics: İstatistik türleri ve değerleri (örn: "Shots on Goal", "Fouls", "Yellow Cards").
5. Örnek Yanıt:
{
"response": [
{
"team": {
"id": 463,
"name": "Aldosivi",
"logo": "https://media.api-sports.io/football/teams/463.png"
},
"statistics": [
{"type": "Shots on Goal", "value": 3},
{"type": "Fouls", "value": 22},
{"type": "Corner Kicks", "value": 3},
{"type": "Yellow Cards", "value": 5},
{"type": "Total passes", "value": 242},
{"type": "Passes accurate", "value": 121}
]
}
]
}
Python Betiği: Maç İstatistiklerini Getirme
Bu uygulama, kullanıcıdan maç ID'sini (fixture) ve isteğe bağlı takım ID'sini alır. Gelen istatistikleri tablo şeklinde gösterir.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QProgressBar, QWidget
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchStatisticsThread(QThread):
progress = pyqtSignal(int)
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, fixture_id, team_id=None):
super().__init__()
self.fixture_id = fixture_id
self.team_id = team_id
def run(self):
try:
# API URL'sini oluştur
url = f"{BASE_URL}fixtures/statistics?fixture={self.fixture_id}"
if self.team_id:
url += f"&team={self.team_id}"
# API isteği gönder
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
stats = response.json().get("response", [])
if not stats:
self.error.emit("Bu maça ait istatistik bulunamadı.")
return
data = []
for team_stats in stats:
team_name = team_stats["team"]["name"]
for stat in team_stats["statistics"]:
data.append({
"team": team_name,
"type": stat["type"],
"value": stat["value"]
})
self.data_ready.emit(data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class StatisticsApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Maç İstatistikleri")
self.resize(800, 600)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
input_layout = QHBoxLayout()
input_layout.addWidget(QLabel("Maç ID (Fixture):"))
self.fixture_input = QLineEdit()
input_layout.addWidget(self.fixture_input)
input_layout.addWidget(QLabel("Takım ID (Opsiyonel):"))
self.team_input = QLineEdit()
input_layout.addWidget(self.team_input)
self.fetch_button = QPushButton("İstatistikleri Getir")
self.fetch_button.clicked.connect(self.fetch_data)
input_layout.addWidget(self.fetch_button)
layout.addLayout(input_layout)
# İlerleme Çubuğu
self.progress_bar = QProgressBar()
layout.addWidget(self.progress_bar)
# Tablo
self.table = QTableWidget(0, 3)
self.table.setHorizontalHeaderLabels(["Takım", "İstatistik Türü", "Değer"])
self.table.horizontalHeader().setStretchLastSection(True)
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
fixture_id = self.fixture_input.text()
team_id = self.team_input.text() or None
if not fixture_id.isdigit():
QLabel("Geçerli bir Maç ID girin!")
return
self.progress_bar.setValue(0)
self.fetch_button.setEnabled(False)
self.thread = FetchStatisticsThread(fixture_id, team_id)
self.thread.progress.connect(self.progress_bar.setValue)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(item["team"]))
self.table.setItem(row, 1, QTableWidgetItem(item["type"]))
self.table.setItem(row, 2, QTableWidgetItem(str(item["value"])))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QLabel(f"Hata: {message}")
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = StatisticsApp()
window.show()
sys.exit(app.exec_())
Kullanım Talimatları:
1.
Maç ID (Fixture) alanına geçerli bir maç ID'si girin.
2.
Takım ID (opsiyonel) girerseniz yalnızca o takıma ait istatistikler çekilir.
3.
"İstatistikleri Getir" butonuna basın.
4.
Gelen istatistikler tablo halinde görüntülenir.
Bu uygulama, belirli bir maça ait tüm istatistikleri kullanıcının seçimine göre sunar! 🚀

--------------------------------------------------------------------------------
headtohead
Head To Head Endpoint Analizi ve Raporu
1. Tanım ve Kullanım Alanı:
●
Head To Head (H2H): İki takım arasındaki geçmiş ve gelecek karşılaşmaların detaylarını getirir.
●
Bu endpoint, belirli iki takımın karşılıklı maç geçmişlerini analiz etmek ve gelecekteki maçlarını öğrenmek için kullanılır.
2. API Özellikleri:
●
Güncelleme Sıklığı: Her 15 saniyede bir güncellenir.
●
Önerilen Çağrı Limiti:
●
Canlı Maçlar: Dakikada 1 çağrı.
●
Normal Kullanım: Günde 1 çağrı.
●
URL: https://v3.football.api-sports.io/fixtures/headtohead
3. Gerekli Parametreler:
●
h2h: Zorunlu. İki takımın ID’leri. Format: ID-ID.
●
Örnek: h2h=33-34 (Manchester United ve Newcastle).
●
Opsiyonel Parametreler:
●
date: Belirli bir tarih için filtreleme (YYYY-MM-DD).
●
league: Lig kimliği (ID).
●
season: 4 haneli yıl (2024 vb.).
●
last: Son X maç.
●
next: Gelecekteki X maç.
●
from / to: Tarih aralığı (YYYY-MM-DD).
●
status: Maç durumu (NS, FT vb.).
●
venue: Mekan kimliği.
●
timezone: Zaman dilimi.
4. API Yanıt Formatı:
●
response: Bir dizi maç bilgilerini içerir.
●
İçindeki Önemli Alanlar:
●
fixture: Maç bilgileri (tarih, zaman, mekan vb.).
●
league: Lig bilgisi (adı, ülke, sezon).
●
teams: Takım bilgileri (ev sahibi ve deplasman).
●
goals: Maç skoru.
●
score: İlk yarı, tam zamanlı ve penaltı skorları.
5. Örnek Yanıt
{
"response": [
{
"fixture": {
"id": 157201,
"date": "2019-12-26T17:30:00+00:00",
"venue": {"name": "Old Trafford", "city": "Manchester"},
"status": {"short": "FT"}
},
"league": {"name": "Premier League", "season": 2019},
"teams": {
"home": {"name": "Manchester United"},
"away": {"name": "Newcastle"}
},
"goals": {"home": 4, "away": 1},
"score": {"halftime": {"home": 3, "away": 1}}
}
]
}
Uygulama Betiği: Head To Head Python Betiği
Bu betik iki takımın karşılıklı maçlarını getirir. Kullanıcıdan takım ID’lerini, isteğe bağlı olarak maç tarihini ve lig sezonunu alabilir.
Kod:
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QPushButton,
QTableWidget, QTableWidgetItem, QLabel, QLineEdit, QProgressBar, QWidget
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchH2HThread(QThread):
progress = pyqtSignal(int)
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, team_ids):
super().__init__()
self.team_ids = team_ids
def run(self):
try:
url = f"{BASE_URL}fixtures/headtohead?h2h={self.team_ids}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
matches = response.json().get("response", [])
total = len(matches)
data = []
for idx, match in enumerate(matches):
data.append({
"league": match["league"]["name"],
"season": match["league"]["season"],
"date": match["fixture"]["date"],
"home": match["teams"]["home"]["name"],
"away": match["teams"]["away"]["name"],
"score": f"{match['goals']['home']} - {match['goals']['away']}",
})
self.progress.emit(int((idx + 1) / total * 100))
self.data_ready.emit(data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class H2HApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Head to Head Maç Bilgileri")
self.resize(800, 600)
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Input Alanı
input_layout = QHBoxLayout()
input_layout.addWidget(QLabel("Takım ID'leri (ID1-ID2):"))
self.team_input = QLineEdit()
input_layout.addWidget(self.team_input)
self.fetch_button = QPushButton("Veri Getir")
self.fetch_button.clicked.connect(self.fetch_data)
input_layout.addWidget(self.fetch_button)
layout.addLayout(input_layout)
# İlerleme Çubuğu
self.progress_bar = QProgressBar()
layout.addWidget(self.progress_bar)
# Tablo
self.table = QTableWidget(0, 6)
self.table.setHorizontalHeaderLabels(["Lig", "Sezon", "Tarih", "Ev Sahibi", "Deplasman", "Skor"])
self.table.horizontalHeader().setStretchLastSection(True)
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
team_ids = self.team_input.text()
if not team_ids or "-" not in team_ids:
QLabel("Hatalı giriş! Lütfen ID1-ID2 formatında giriniz.")
return
self.progress_bar.setValue(0)
self.fetch_button.setEnabled(False)
self.thread = FetchH2HThread(team_ids)
self.thread.progress.connect(self.progress_bar.setValue)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(item["league"]))
self.table.setItem(row, 1, QTableWidgetItem(str(item["season"])))
self.table.setItem(row, 2, QTableWidgetItem(item["date"]))
self.table.setItem(row, 3, QTableWidgetItem(item["home"]))
self.table.setItem(row, 4, QTableWidgetItem(item["away"]))
self.table.setItem(row, 5, QTableWidgetItem(item["score"]))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QLabel(f"Hata: {message}")
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = H2HApp()
window.show()
sys.exit(app.exec_())
Kullanım Talimatları:
1.
İki takımın ID'lerini ID1-ID2 formatında gir.
2.
"Veri Getir" butonuna bas.
3.
H2H geçmişi tabloya yüklenecek.
Bu uygulama, iki takımın karşılıklı maç bilgilerini çekip ekrana yansıtır. 🚀

--------------------------------------------------------------------------------
fikstür bülten çekme
Fixtures Nedir ve Ne İşe Yarar?
"Fixtures" uç noktası, bir ligin, takımın veya turnuvanın maç programlarını detaylı bir şekilde almanıza olanak tanır.
Bu uç nokta sayesinde:
●
Maç Programı: Tüm maçların tarihleri, saatleri, statüleri (oynanmış, oynanacak, ertelenmiş vb.) ve skor bilgileri alınabilir.
●
Gerçek Zamanlı Bilgi: Canlı maçları görüntülemek, durumlarını güncellemek veya geçmiş maç sonuçlarını çekmek mümkündür.
●
İstatistiksel Çıkarımlar: Lig ve sezon bazlı analizler yapmak için gerekli olan veriler sağlanır.
Kullanım Alanları:
●
Maç programı hazırlamak ve göstermek.
●
Gerçek zamanlı canlı skor uygulamaları.
●
Sezon ve takım performans analizleri.
●
Geçmiş maçlara yönelik veri analizi ve raporlama.
2. Fixtures İçindeki Önemli Alanlar
1.
Fixture Bilgisi (fixture):
●
id: Maçın benzersiz ID'si.
●
date: Maçın oynanacağı tarih ve saat.
●
status: Maçın durumu (NS, FT, AET, PEN, vb.).
●
venue: Maçın oynanacağı stadyum bilgisi (ID, isim ve şehir).
●
timezone: Maçın bulunduğu zaman dilimi.
1.
Lig Bilgisi (league):
●
id: Ligin ID'si.
●
name: Ligin adı.
●
season: Ligin sezonu.
1.
Takımlar Bilgisi (teams):
●
home: Ev sahibi takım bilgileri (isim, logo, kazanan).
●
away: Deplasman takım bilgileri (isim, logo, kazanan).
1.
Skor Bilgisi (goals & score):
●
halftime: İlk yarı skoru.
●
fulltime: Maç sonu skoru.
●
extratime & penalty: Uzatmalar ve penaltı skoru.
3. Kullanılacak Parametreler ve Özellikler
Bu uç nokta oldukça esnek ve çeşitli filtrelerle kullanılabilir:
●
Lig ve Sezon Filtreleme: Belirli bir ligin ve sezonun tüm maçlarını çekebiliriz.
●
Tarih Aralığı Filtreleme: from ve to parametreleri ile belirli tarih aralığındaki maçları çekebiliriz.
●
Durum Filtreleme:
●
NS: Henüz başlamamış maçlar.
●
FT: Tamamlanmış maçlar.
●
LIVE: Devam eden maçlar.
●
Takım Filtreleme: Sadece belirli bir takımın maçlarını çekebiliriz.
●
Zaman Dilimi: Maç programını kullanıcının istediği zaman diliminde gösterebiliriz.
4. Veri Yapısının Zorluğu ve Batch Mantığı
Fixtures uç noktası büyük veri döndürebilir çünkü:
●
Bir ligin 380 maçını içerebilir.
●
Aynı anda birden fazla lig ve sezonun maçları çekilebilir.
Batch Yapısının Önemi:
●
API, tek seferde en fazla 20 fixture ID isteğini destekler. Bu nedenle:
1.
Tüm maç ID'lerini toplamalıyız.
2.
ID'leri 20'lik parçalara ayırmalıyız.
3.
Her bir grubu belirli bir gecikme (örneğin, 1 saniye) ile API'ye göndermeliyiz.
Progress Bar Kullanımı:
●
Verilerin toplandığı ve işlendiği aşamaları kullanıcıya göstermek için bir progress bar kullanmak şart.
●
Batch yapıdaki her istekte ilerleme yüzdesini güncellemeliyiz.
5. Kullanılacak Algoritma Akışı
Adım 1: İlk olarak belirli bir lig ve sezona ait tüm fixture ID'lerini çek.
Adım 2: Elde edilen ID'leri 20'lik gruplara böl.
Adım 3: Her bir grubu API'ye gönder ve fixture detaylarını al.
Adım 4: Gelen verileri tablo yapısında ve kullanıcı dostu bir arayüzde göster.
Adım 5: Kullanıcıya progress bar ile veri işleme durumunu göster.
6. Örnek Rapor Yapısı
Rapor içeriğinde:
●
Lig adı ve sezon.
●
Ev sahibi ve deplasman takımı bilgileri.
●
Maç durumu ve skoru (ilk yarı, tam zaman, penaltı).
●
Maç tarihi ve oynandığı stadyum.
Bu verileri tablo yapısında göstereceğiz ve gerektiğinde Excel gibi bir formata aktaracağız.
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QPushButton, QTableWidget,
QTableWidgetItem, QLabel, QProgressBar, QMessageBox, QWidget, QDateEdit, QHBoxLayout
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QDate
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchFixturesThread(QThread):
progress = pyqtSignal(int)
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, selected_date):
super().__init__()
self.selected_date = selected_date
def run(self):
try:
# Tarihe göre veri çekme
url = f"{BASE_URL}fixtures?date={self.selected_date}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
fixtures = response.json().get("response", [])
total = len(fixtures)
result_data = []
for idx, fixture in enumerate(fixtures):
result_data.append({
"league": fixture["league"]["name"],
"date": fixture["fixture"]["date"],
"home": fixture["teams"]["home"]["name"],
"away": fixture["teams"]["away"]["name"],
"score": fixture["score"]["fulltime"] or "TBD",
})
self.progress.emit(int((idx + 1) / total * 100))
self.data_ready.emit(result_data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class FixturesApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Maç Programı (Tarih Bazlı)")
self.showFullScreen() # Pencereyi tam ekran modunda başlat
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Tarih Seçici
date_layout = QHBoxLayout()
self.date_input = QDateEdit()
self.date_input.setCalendarPopup(True)
self.date_input.setDate(QDate.currentDate())
date_layout.addWidget(QLabel("Tarih Seçin:"))
date_layout.addWidget(self.date_input)
self.fetch_button = QPushButton("Veri Getir")
self.fetch_button.clicked.connect(self.fetch_data)
date_layout.addWidget(self.fetch_button)
layout.addLayout(date_layout)
# İlerleme Çubuğu
self.progress_bar = QProgressBar()
layout.addWidget(self.progress_bar)
# Tablo
self.table = QTableWidget(0, 5)
self.table.setHorizontalHeaderLabels(["Lig", "Tarih", "Ev Sahibi", "Deplasman", "Skor"])
self.table.horizontalHeader().setStretchLastSection(True)
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
selected_date = self.date_input.date().toString("yyyy-MM-dd")
self.progress_bar.setValue(0)
self.fetch_button.setEnabled(False)
self.thread = FetchFixturesThread(selected_date)
self.thread.progress.connect(self.progress_bar.setValue)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(item["league"]))
self.table.setItem(row, 1, QTableWidgetItem(item["date"]))
self.table.setItem(row, 2, QTableWidgetItem(item["home"]))
self.table.setItem(row, 3, QTableWidgetItem(item["away"]))
self.table.setItem(row, 4, QTableWidgetItem(str(item["score"])))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QMessageBox.critical(self, "Hata", message)
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = FixturesApp()
window.show()
sys.exit(app.exec_())
import requests
import sys
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QPushButton, QTableWidget,
QTableWidgetItem, QLabel, QProgressBar, QMessageBox, QWidget, QDateEdit, QHBoxLayout
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QDate
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Planda Çalışan Thread
class FetchFixturesThread(QThread):
progress = pyqtSignal(int)
data_ready = pyqtSignal(list)
error = pyqtSignal(str)
def __init__(self, selected_date):
super().__init__()
self.selected_date = selected_date
def run(self):
try:
# Tarihe göre veri çekme
url = f"{BASE_URL}fixtures?date={self.selected_date}"
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
fixtures = response.json().get("response", [])
total = len(fixtures)
result_data = []
for idx, fixture in enumerate(fixtures):
result_data.append({
"league": fixture["league"]["name"],
"date": fixture["fixture"]["date"],
"home": fixture["teams"]["home"]["name"],
"away": fixture["teams"]["away"]["name"],
"score": fixture["score"]["fulltime"] or "TBD",
})
self.progress.emit(int((idx + 1) / total * 100))
self.data_ready.emit(result_data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class FixturesApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Maç Programı (Tarih Bazlı)")
self.showFullScreen() # Pencereyi tam ekran modunda başlat
central_widget = QWidget()
self.setCentralWidget(central_widget)
layout = QVBoxLayout()
# Tarih Seçici
date_layout = QHBoxLayout()
self.date_input = QDateEdit()
self.date_input.setCalendarPopup(True)
self.date_input.setDate(QDate.currentDate())
date_layout.addWidget(QLabel("Tarih Seçin:"))
date_layout.addWidget(self.date_input)
self.fetch_button = QPushButton("Veri Getir")
self.fetch_button.clicked.connect(self.fetch_data)
date_layout.addWidget(self.fetch_button)
layout.addLayout(date_layout)
# İlerleme Çubuğu
self.progress_bar = QProgressBar()
layout.addWidget(self.progress_bar)
# Tablo
self.table = QTableWidget(0, 5)
self.table.setHorizontalHeaderLabels(["Lig", "Tarih", "Ev Sahibi", "Deplasman", "Skor"])
self.table.horizontalHeader().setStretchLastSection(True)
layout.addWidget(self.table)
central_widget.setLayout(layout)
def fetch_data(self):
selected_date = self.date_input.date().toString("yyyy-MM-dd")
self.progress_bar.setValue(0)
self.fetch_button.setEnabled(False)
self.thread = FetchFixturesThread(selected_date)
self.thread.progress.connect(self.progress_bar.setValue)
self.thread.data_ready.connect(self.update_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def update_table(self, data):
self.table.setRowCount(0)
for item in data:
row = self.table.rowCount()
self.table.insertRow(row)
self.table.setItem(row, 0, QTableWidgetItem(item["league"]))
self.table.setItem(row, 1, QTableWidgetItem(item["date"]))
self.table.setItem(row, 2, QTableWidgetItem(item["home"]))
self.table.setItem(row, 3, QTableWidgetItem(item["away"]))
self.table.setItem(row, 4, QTableWidgetItem(str(item["score"])))
self.fetch_button.setEnabled(True)
def show_error(self, message):
QMessageBox.critical(self, "Hata", message)
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = FixturesApp()
window.show()
sys.exit(app.exec_())

--------------------------------------------------------------------------------
Football APIs: A Preliminary Note
Metin, "Api football" ifadesini içeren, kısaca futbol API'leri ile ilgili olduğunu düşündüren bir alıntı sunmaktadır. Alıntının kaynağı ve içeriği sınırlı olduğundan, konu hakkında daha fazla bilgi edinmek için ek bilgi gereklidir. "Api football" terimi, futbol verilerini sağlayan uygulama programlama arayüzlerine işaret ediyor olabilir. Bu arayüzler, futbol istatistikleri, maç sonuçları veya oyuncu bilgileri gibi çeşitli verileri sunabilir. Ancak metin, bu konuda kesin bir bilgi sağlamamaktadır.

--------------------------------------------------------------------------------
bir ligin turlarını görmek için
Rounds Endpoint: Detaylı Açıklama
1. Amaç ve Kullanımı
●
Amacı: Belirli bir ligin ya da kupanın mevcut sezonundaki turlar listesini almak için kullanılır.
●
Kullanım Alanı:Fikstür Verisi Filtreleme: Fikstür endpoint'i (/fixtures) ile birlikte kullanılarak belirli bir turun maçlarını çekebilirsiniz.
●
Mevcut Tur Bilgisi: Bir sezonda şu anda oynanan ya da yaklaşan turun bilgisini almak için kullanılabilir.
●
Tarihleri Almak: Parametre olarak dates=true kullanarak her turun başlangıç/bitiş tarihini alabilirsiniz.
2. Parametreler
Parametre Zorunlu Açıklama league Evet Ligin ya da kupanın ID'si. season Evet Sezonun yılı (4 haneli, örneğin 2019). current Hayır true ise sadece şu anda oynanan turu getirir, diğerlerini dışlar. dates Hayır true ise her turun başlangıç/bitiş tarihlerini getirir. timezone Hayır Veriyi belirli bir zaman diliminde almak için (örn: "Europe/Istanbul"). 3. Yanıt Yapısı
API'den dönen yanıtın örnek yapısı şu şekildedir:
{
"get": "fixtures/rounds",
"parameters": {
"league": "39",
"season": "2019"
},
"errors": [],
"results": 38,
"response": [
"Regular Season - 1",
"Regular Season - 2",
"Regular Season - 3",
...
]
}
●
response Alanı: Ligdeki tüm turların isimlerini içerir (örneğin: "Regular Season - 1").
●
results: Toplam kaç tur olduğunu gösterir.
●
parameters: Sorgu parametrelerini listeler.
4. Senaryo ve Mantık
1.
İlk adımda belirli bir lig ve sezona ait turlar çekilir.
2.
Eğer current=true parametresi eklenirse, sadece şu anki tur döner.
3.
Büyük veri yapıları varsa turların çekilmesi batch yapısında yapılabilir (API'nin rate limit'ine dikkat ederek).
4.
Her turun verisi tabloya eklenir.
5. Örnek Python Betiği (Tam Teşekküllü Arayüz ile)
Bu betik:
●
Kullanıcıdan lig ID'si ve sezon bilgisi alır.
●
Belirtilen ligin turlarını getirir ve tabloya ekler.
●
Eğer dates=true kullanılırsa, başlangıç ve bitiş tarihlerini de ekler.
●
İşlem ilerleyişini progress bar ile gösterir.
Kod:
Kodunuz güncellendi! Bu örnekte, lig ve sezon bilgilerini girerek o sezona ait turlar listesini tablo halinde görüntüleyebilirsiniz. Veriler batch mantığı ve ilerleme çubuğu (progress bar) ile işlenmektedir. Başka bir geliştirme ihtiyacınız varsa, buradayım!

--------------------------------------------------------------------------------
Tüm aktif liglerin puan durumunu almak
Öncelikle Kullanım Kılavuzunu Anlayalım
1. Kullanım Amacı:
Bu yapı, tüm aktif liglerin puan durumlarını (standings) almak için kullanılır.
●
Standings, lig veya kupaların mevcut sıralama tablolarını döner.
●
Eğer bir ligde birden fazla sıralama (grup aşaması, açılış, kapanış gibi) varsa, bu veriler de döner.
Amaç:
1.
Tüm aktif ligleri bulmak.
2.
Bu liglerde standings (puan durumu) bilgisinin mevcut olduğunu kontrol etmek.
3.
Ligin ID'sini ve aktif sezon yılını alarak standings endpoint'ine sorgu göndermek.
4.
Sonuçta, tüm mevcut puan durumlarını toplamak.
2. Gerekli Parametreler:
●
league (zorunlu): Lig ID'si (integer).
●
season (zorunlu): Sezon yılı (4 karakter, örn. 2024).
●
team (isteğe bağlı): Belirli bir takımın ID'si.
3. Kullanım Adımları:
1.
Aktif Ligleri Getir:
●
leagues endpoint'ine current=true parametresi ile sorgu gönder.
●
Bu sorgu, sadece aktif sezonları döner.
1.
Örnek:
2.
GET /leagues?current=true
3.
Standings Bilgisi Mevcut Olan Ligleri Filtrele:
●
Dönen veride coverage -> standings alanı true olan ligleri seç.
●
Bu, ligde standings bilgisinin mevcut olup olmadığını kontrol eder.
1.
Standings Endpoint'ine Sorgu Gönder:
●
Her bir ligin ID'si ve sezon yılı ile standings endpoint'ine sorgu yap.
●
standings?league={id}&season={year} kullanılır.
1.
Verileri Topla:
●
Her ligin standings sonuçlarını kaydet veya göster.
4. API Sınırlamaları:
●
Rate Limit (Saniye Başına İstek): API'ye bir dakikada belirli sayıda istek gönderilebilir.
●
Örneğin, ücretsiz planda saniyede sadece 1 istek gönderebilirsiniz.
●
Çözüm: Sorgular arasında gecikme (time.sleep()) eklemek gerekir.
5. JSON Yanıt Formatı:
Örnek Yanıt:
{
"get": "standings",
"parameters": {
"league": "39",
"season": "2019"
},
"response": [
{
"league": {
"id": 39,
"name": "Premier League",
"season": 2019,
"standings": [
[
{
"rank": 1,
"team": { "id": 40, "name": "Liverpool" },
"points": 70,
"goalsDiff": 41,
"all": { "played": 24, "win": 23, "draw": 1, "lose": 0 }
}
]
]
}
}
]
}
6. Python Betik Adımları:
1.
Aktif Ligleri Al.
2.
Standings Bilgisi Olan Ligleri Filtrele.
3.
Her Ligin ID'si ve Sezonu ile Standings Verilerini Al.
4.
Veriyi Görselleştir veya Kaydet.
Tam Teşekküllü Python Betik
Aşağıdaki betik, PyQt5 arayüzü kullanarak ligleri ve standings bilgilerini alır ve tablo halinde gösterir.
import requests
import sys
import time
from PyQt5.QtWidgets import QApplication, QWidget, QVBoxLayout, QPushButton, QTableWidget, QTableWidgetItem, QLabel, QMessageBox
from PyQt5.QtCore import QThread, pyqtSignal
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58"
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# Arka Plan Thread'i
class StandingsThread(QThread):
finished = pyqtSignal(list)
error = pyqtSignal(str)
def run(self):
try:
leagues_url = f"{BASE_URL}leagues?current=true"
response = requests.get(leagues_url, headers=HEADERS)
response.raise_for_status()
# Aktif ligleri filtrele
leagues = response.json().get("response", [])
standings_leagues = [
{"league": league["league"]["id"], "season": season["year"]}
for league in leagues
for season in league.get("seasons", [])
if season["current"] and season["coverage"]["standings"]
]
# Her lig için standings verilerini al
standings_data = []
for entry in standings_leagues:
standings_url = f"{BASE_URL}standings?league={entry['league']}&season={entry['season']}"
response = requests.get(standings_url, headers=HEADERS)
time.sleep(1) # Rate limit'i aşmamak için bekleme
response.raise_for_status()
standings_data.append(response.json().get("response", []))
self.finished.emit(standings_data)
except Exception as e:
self.error.emit(str(e))
# Ana Arayüz
class StandingsApp(QWidget):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Puan Durumu Bilgileri")
self.resize(800, 600)
layout = QVBoxLayout()
self.label = QLabel("Puan durumu verilerini getirmek için butona tıklayın.")
layout.addWidget(self.label)
self.fetch_button = QPushButton("Puan Durumlarını Al")
self.fetch_button.clicked.connect(self.fetch_standings)
layout.addWidget(self.fetch_button)
self.table = QTableWidget()
self.table.setColumnCount(4)
self.table.setHorizontalHeaderLabels(["Lig Adı", "Sezon", "Takım", "Puan"])
layout.addWidget(self.table)
self.setLayout(layout)
def fetch_standings(self):
self.label.setText("Veri alınıyor, lütfen bekleyin...")
self.fetch_button.setEnabled(False)
self.thread = StandingsThread()
self.thread.finished.connect(self.populate_table)
self.thread.error.connect(self.show_error)
self.thread.start()
def populate_table(self, standings_data):
self.table.setRowCount(0)
for league_data in standings_data:
for league in league_data:
league_name = league["league"]["name"]
season = league["league"]["season"]
for group in league["league"]["standings"]:
for team in group:
row_position = self.table.rowCount()
self.table.insertRow(row_position)
self.table.setItem(row_position, 0, QTableWidgetItem(league_name))
self.table.setItem(row_position, 1, QTableWidgetItem(str(season)))
self.table.setItem(row_position, 2, QTableWidgetItem(team["team"]["name"]))
self.table.setItem(row_position, 3, QTableWidgetItem(str(team["points"])))
self.label.setText("Veri başarıyla alındı!")
self.fetch_button.setEnabled(True)
def show_error(self, error_msg):
QMessageBox.critical(self, "Hata", f"Veri çekilirken hata oluştu:\n{error_msg}")
self.label.setText("Hata oluştu, tekrar deneyin.")
self.fetch_button.setEnabled(True)
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = StandingsApp()
window.show()
sys.exit(app.exec_())
Özellikler:
1.
Aktif Ligleri Alır.
2.
Standings Bilgisi Mevcut Olan Ligleri Filtreler.
3.
Puan Durumu Bilgilerini Gösterir (Lig, Sezon, Takım, Puan).
4.
Rate Limit Yönetimi: 1 saniye bekleme (time.sleep(1)) eklenmiştir.
Bu betik, tam teşekküllü bir çözüm sunar! Her aşamayı birlikte tartışabiliriz. 😊

--------------------------------------------------------------------------------
ülkelerin listesini,ülkelere ait takımları getirir.
Teams Countries Kullanım Kılavuzu
Amacı:
Bu endpoint, teams endpoint'inde kullanılabilecek ülkelerin listesini döner. Bu ülkeler, takımların mevcut olduğu coğrafi bölgeleri temsil eder. Örneğin, İngiltere (England) için kodu GB döner. Ayrıca her ülke için bayrak görselinin URL'si de döner.
Kullanım Senaryosu:
1.
Takım Ülkeleri Listesi: Bu endpoint, sistemde mevcut olan ülkeleri listeler. Ülkeler, belirli takımların ait olduğu bölgeyi belirtmek için kullanılabilir.
2.
Filtreleme: Eğer bir kullanıcı sadece belirli bir ülkeye ait takımları incelemek istiyorsa, bu ülkelerin listesini önceden alıp ID veya kod ile filtreleme yapabilir.
3.
Bayrak Görselleri: Ülke bayraklarını kullanıcı arayüzünde görselleştirmek için flag URL'sini kullanabilirsiniz.
API Parametreleri:
●
Header:x-apisports-key: API anahtarınız.
●
x-apisports-host: Sabit host değeri: v3.football.api-sports.io
Yanıt Formatı (Response)
Başarılı yanıt durumunda (200 OK), aşağıdaki veriler döner:
●
name: Ülke adı (örnek: England).
●
code: Ülke kodu (örnek: GB - ISO Alpha-2 formatında).
●
flag: Ülke bayrağı URL'si (görsel olarak eklenebilir).
Hata Yanıtları:
●
204 No Content: Veri yok veya parametreler yanlış.
●
499/500 Hata: Sunucu hatası veya zaman aşımı.
Python Betik: Teams Countries Listeleme
Bu Python betiği, API'den tüm ülkeleri çekip bir Qt5 arayüzünde tablo olarak gösterir. Bayrak görselleri de tabloya eklenmiştir.
Kod:
import requests
from PyQt5.QtWidgets import (
QApplication, QWidget, QVBoxLayout, QPushButton, QTableWidget,
QTableWidgetItem, QLabel, QMessageBox
)
from PyQt5.QtGui import QPixmap
from PyQt5.QtCore import Qt
import sys
from io import BytesIO
# API Ayarları
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58" # API anahtarınız
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# API'den veri çekme fonksiyonu
def fetch_data(endpoint):
url = f"{BASE_URL}{endpoint}"
try:
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
return response.json()
except requests.exceptions.RequestException as e:
return {"error": str(e)}
# Ana Uygulama Sınıfı
class CountriesApp(QWidget):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
# Arayüz ayarları
self.setWindowTitle("Takım Ülkeleri Listesi")
self.setGeometry(100, 100, 800, 600)
layout = QVBoxLayout()
# Buton ve Tablo
self.fetch_button = QPushButton("Ülkeleri Getir")
self.fetch_button.clicked.connect(self.fetch_countries)
layout.addWidget(self.fetch_button)
self.table = QTableWidget()
self.table.setColumnCount(3)
self.table.setHorizontalHeaderLabels(["Ülke Adı", "Ülke Kodu", "Bayrak"])
self.table.horizontalHeader().setStretchLastSection(True)
layout.addWidget(self.table)
self.setLayout(layout)
def fetch_countries(self):
# API'den veri çek
self.fetch_button.setText("Veri alınıyor...")
data = fetch_data("teams/countries")
self.fetch_button.setText("Ülkeleri Getir")
if "error" in data or not data.get("response"):
QMessageBox.critical(self, "Hata", f"Veri alınamadı: {data.get('error', 'Bilinmeyen hata')}")
return
# Tabloyu doldur
response_data = data.get("response", [])
self.table.setRowCount(len(response_data))
for row, country in enumerate(response_data):
name = country.get("name", "Bilinmiyor")
code = country.get("code", "Bilinmiyor")
flag_url = country.get("flag", "")
# Ülke Adı ve Kodu
self.table.setItem(row, 0, QTableWidgetItem(name))
self.table.setItem(row, 1, QTableWidgetItem(code))
# Bayrak Görseli
if flag_url:
pixmap = self.get_flag_pixmap(flag_url)
if pixmap:
label = QLabel()
label.setPixmap(pixmap)
label.setAlignment(Qt.AlignCenter)
self.table.setCellWidget(row, 2, label)
else:
self.table.setItem(row, 2, QTableWidgetItem("Bayrak Yok"))
def get_flag_pixmap(self, url):
try:
response = requests.get(url)
response.raise_for_status()
image_data = BytesIO(response.content)
pixmap = QPixmap()
pixmap.loadFromData(image_data.read())
return pixmap.scaled(50, 50, Qt.KeepAspectRatio)
except:
return None
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = CountriesApp()
window.show()
sys.exit(app.exec_())
Kod Açıklaması:
1.
Veri Çekme: fetch_data() fonksiyonu teams/countries endpoint'inden veri alır.
2.
Tablo Yapısı: Ülke adı, ülke kodu ve bayrak görselini 3 sütunlu bir tablo halinde gösterir.
3.
Bayrak Görselleri: QPixmap kullanarak bayrak URL'sinden görsel yükler ve tabloya ekler.
4.
Hata Yönetimi: API hatalarını ve ağ sorunlarını kullanıcıya mesaj kutusu ile bildirir.
5.
Kullanıcı Dostu: Veriyi çekme işlemi sırasında butonun durumunu günceller.
Kullanım:
1.
Programı çalıştırın.
2.
"Ülkeleri Getir" butonuna tıklayarak ülkelerin listesini tablo olarak görüntüleyin.
3.
Ülke isimleri, kodları ve bayrak görselleri otomatik olarak tabloya eklenir.
Bu yapı, takımların bulunduğu ülkeleri listelemek için hızlı ve görsel bir çözüm sunar.

--------------------------------------------------------------------------------
Takım istatistiklerinin çekilmesi
Kullanım Kılavuzu: "Teams Statistics" Endpoint
Amacı: Bu endpoint, belirli bir lig, sezon ve takım için istatistikleri çekmek için kullanılır.
Sorgu Parametreleri
API'ye yapılan istekte kullanılan parametreler:
1.
league (required): Ligin ID'si. Bu ID, leagues endpoint'inden alınır.
2.
season (required): 4 haneli sezon yılı (örn: 2019).
3.
team (required): Takımın ID'si. Bu ID, teams endpoint'inden alınır.
4.
date (optional): YYYY-MM-DD formatında belirli bir tarihe kadar olan istatistikleri almak için kullanılır. Tarih verilmezse sezon başından itibaren tüm veriler getirilir.
Header Parametreleri
●
x-rapidapi-key: API Anahtarınız.
●
x-rapidapi-host: API host adresi (v3.football.api-sports.io).
Yanıt Formatı (Response)
200 OK:
Başarılı istek durumunda dönen veri:
●
team: Takım ID'si ve adı.
●
league: Lig adı, ülke bilgisi ve sezon.
●
form: Son maçların form durumu (örn: WDLDW).
●
fixtures: Oynanan maç sayısı, galibiyet, beraberlik ve mağlubiyet sayıları.
●
goals: Atılan ve yenilen gollerin detayları (toplam, ortalama, zaman aralığı dağılımı).
●
biggest: En büyük galibiyet ve mağlubiyetler.
●
clean_sheet: Gol yemeden tamamlanan maç sayısı.
●
penalty: Penaltı istatistikleri (kaçan, atılan).
●
lineups: Kullanılan dizilişler ve oynanan maç sayıları.
●
cards: Sarı ve kırmızı kartların dakika dağılımı.
204 No Content:
Bu durumda yanıt verisi boş döner. Genellikle hatalı parametre gönderildiğinde oluşur.
499/500 Hata:
Sunucu hatası veya zaman aşımı durumunda dönen hata mesajlarıdır.
Tam Teşekküllü Python Örneği: Qt5 Arayüzüyle Takım İstatistikleri Çekme
Bu betik, kullanıcının lig, sezon ve takım ID'si girmesini sağlayarak takım istatistiklerini tablo halinde görüntüleyen bir Qt5 uygulamasıdır. Ayrıca veriyi .txt dosyasına kaydetme özelliği eklenmiştir.
Kod
import requests
import json
from PyQt5.QtWidgets import (
QApplication, QWidget, QVBoxLayout, QPushButton, QTextEdit,
QFileDialog, QLabel, QLineEdit, QTableWidget, QTableWidgetItem, QMessageBox
)
import sys
# API Anahtarı ve Ayarlar
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58" # API anahtarınızı buraya girin
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# API'den veri çekme fonksiyonu
def fetch_data(endpoint, params=None):
url = f"{BASE_URL}{endpoint}"
try:
response = requests.get(url, headers=HEADERS, params=params)
response.raise_for_status()
return response.json()
except requests.exceptions.RequestException as e:
return {"error": str(e)}
# Takım İstatistikleri Sorgulama
def get_team_statistics(league_id, season, team_id):
params = {"league": league_id, "season": season, "team": team_id}
return fetch_data("teams/statistics", params)
# Arayüz Sınıfı
class TeamStatsApp(QWidget):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
# Ana Pencere Ayarları
self.setWindowTitle("Takım İstatistikleri")
self.setGeometry(100, 100, 1200, 800)
# Ana Layout
layout = QVBoxLayout()
# Giriş Alanları
self.league_input = QLineEdit(self)
self.league_input.setPlaceholderText("Ligin ID'sini girin")
layout.addWidget(self.league_input)
self.season_input = QLineEdit(self)
self.season_input.setPlaceholderText("Sezonu girin (YYYY)")
layout.addWidget(self.season_input)
self.team_input = QLineEdit(self)
self.team_input.setPlaceholderText("Takım ID'sini girin")
layout.addWidget(self.team_input)
# Butonlar
self.fetch_button = QPushButton("Takım İstatistiklerini Al", self)
self.fetch_button.clicked.connect(self.fetch_team_stats)
layout.addWidget(self.fetch_button)
self.save_button = QPushButton("Dosyaya Kaydet", self)
self.save_button.clicked.connect(self.save_to_file)
self.save_button.setEnabled(False)
layout.addWidget(self.save_button)
# Tablo
self.table = QTableWidget()
self.table.setColumnCount(2)
self.table.setHorizontalHeaderLabels(["İstatistik", "Değer"])
layout.addWidget(self.table)
# Mesaj Alanı
self.message_label = QLabel("")
layout.addWidget(self.message_label)
self.setLayout(layout)
def fetch_team_stats(self):
# Kullanıcıdan Giriş Al
league_id = self.league_input.text()
season = self.season_input.text()
team_id = self.team_input.text()
if not league_id or not season or not team_id:
QMessageBox.warning(self, "Eksik Bilgi", "Lütfen tüm alanları doldurun.")
return
# API'den Veri Çek
self.message_label.setText("Veri alınıyor...")
data = get_team_statistics(league_id, season, team_id)
if "error" in data or not data.get("response"):
QMessageBox.critical(self, "Hata", "Veri alınamadı: Parametreleri kontrol edin.")
return
# Tabloya Veri Ekle
self.table.setRowCount(0)
stats = data.get("response", {})
for key, value in stats.items():
self.add_table_row(key, value)
self.message_label.setText("Veri başarıyla alındı.")
self.save_button.setEnabled(True)
def add_table_row(self, key, value):
# Tabloya Satır Ekle
row_position = self.table.rowCount()
self.table.insertRow(row_position)
self.table.setItem(row_position, 0, QTableWidgetItem(str(key)))
self.table.setItem(row_position, 1, QTableWidgetItem(str(value)))
def save_to_file(self):
# Dosyaya Kaydet
file_path, _ = QFileDialog.getSaveFileName(self, "Dosyayı Kaydet", "", "Text Files (*.txt)")
if file_path:
with open(file_path, "w", encoding="utf-8") as file:
for row in range(self.table.rowCount()):
key = self.table.item(row, 0).text()
value = self.table.item(row, 1).text()
file.write(f"{key}: {value}\n")
QMessageBox.information(self, "Başarılı", "Dosya başarıyla kaydedildi.")
# Uygulama Çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
window = TeamStatsApp()
window.show()
sys.exit(app.exec_())
Kod Özeti:
1.
Giriş Alanları: Lig ID, sezon ve takım ID bilgilerini alır.
2.
API'den Veri Çekme: teams/statistics endpoint'ini kullanarak takım istatistiklerini çeker.
3.
Tablo: API'den dönen verileri tablo formatında görüntüler.
4.
Kaydetme: Verileri .txt dosyasına kaydeder.
5.
Hata Yönetimi: API hataları ve eksik bilgiler için uyarı mesajları içerir.
Özellikler:
●
Tam Ekran Modu: 1200x800 piksel genişlikte çalışır.
●
Dinamik Tablo: API verilerine göre satır ekler.
●
Kullanıcı Dostu: Eksik bilgi veya hata durumunda uyarı mesajları gösterir.
Bu kodu çalıştırarak takımların istatistiklerini hızlıca çekebilir ve inceleyebilirsiniz!

--------------------------------------------------------------------------------
Sezon bilgilerinin sorgulanması
Özet: Seasons API Kullanımı
Amaç:
Mevcut tüm sezonların listesini almak.
API Özellikleri
1.
Endpoint: /leagues/seasons
2.
Parametreler:
3.
Bu endpoint herhangi bir parametre gerektirmez.
4.
Yanıt Formatı:
●
response: Sezonları içeren bir dizi (Array of Strings).
●
results: Dönen toplam sezon sayısı.
●
errors: Eğer varsa hata mesajlarını içerir.
●
paging: Sayfalandırma bilgileri.
1.
Sezon Tanımı:
●
Tüm sezonlar 4 haneli (örneğin, 2018-2019 sezonu için API "2018" döner).
●
Bu sezon bilgileri, filter olarak diğer API uç noktalarında kullanılabilir.
1.
Örnek Yanıt:
2.
{
3.
"get": "leagues/seasons",
4.
"parameters": [],
5.
"errors": [],
6.
"results": 12,
7.
"response": [2008, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020]
8.
}
Arayüz Özellikleri
1.
Kullanıcı sezonları listelemek için bir butona tıklar.
2.
API'den dönen sezonlar bir QTableWidget'ta gösterilir.
3.
Kullanıcı bu bilgileri dosyaya kaydedebilir.
4.
Tam ekran modunda çalışır ve kapat butonu içerir.
Kod Örneği: PyQt5 ile Seasons Arayüzü
Aşağıdaki örnekte, API anahtarınızı kullanarak sezon bilgilerini listeleyen ve tablo yapısında gösteren bir arayüz sunuyorum. Tam ekran modunda çalışacak ve kapat butonu eklenmiştir.
Bu uygulama, API'den sezonları çeker, tablo halinde gösterir ve dosyaya kaydetme imkanı sunar. Tam ekran modunda başlar ve kapat butonu eklenmiştir. Kapsamlı bir test için API anahtarınızı kullanarak deneyebilirsiniz!
import requests
import json
from PyQt5.QtWidgets import (
QApplication, QMainWindow, QVBoxLayout, QPushButton, QTableWidget,
QTableWidgetItem, QWidget, QFileDialog, QMessageBox
)
import sys
# API Ayarı ve Bağlantı
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58" # API Anahtarınız
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
def fetch_data(endpoint):
"""
API'den veri çekme fonksiyonu.
"""
url = f"{BASE_URL}{endpoint}"
try:
response = requests.get(url, headers=HEADERS)
response.raise_for_status()
return response.json()
except requests.exceptions.RequestException as e:
return {"error": str(e)}
class SeasonApp(QMainWindow):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
self.setWindowTitle("Aktif Sezon Bilgileri")
self.setGeometry(100, 100, 800, 600)
self.showFullScreen() # Tam ekran modu
# Ana Widget ve Layout
main_widget = QWidget()
self.layout = QVBoxLayout(main_widget)
self.setCentralWidget(main_widget)
# Sezon Tablosu
self.table = QTableWidget()
self.table.setColumnCount(1)
self.table.setHorizontalHeaderLabels(["Sezonlar"])
self.layout.addWidget(self.table)
# Butonlar
self.fetch_button = QPushButton("Sezon Bilgilerini Al")
self.fetch_button.clicked.connect(self.fetch_seasons)
self.layout.addWidget(self.fetch_button)
self.save_button = QPushButton("Dosyaya Kaydet")
self.save_button.clicked.connect(self.save_to_file)
self.save_button.setEnabled(False)
self.layout.addWidget(self.save_button)
self.close_button = QPushButton("Kapat")
self.close_button.clicked.connect(self.close)
self.layout.addWidget(self.close_button)
def fetch_seasons(self):
"""
Sezon bilgilerini API'den çek ve tabloya yansıt.
"""
self.table.clearContents()
self.table.setRowCount(0)
data = fetch_data("leagues/seasons")
if "error" in data:
QMessageBox.warning(self, "API Hatası", data["error"])
return
seasons = data.get("response", [])
if seasons:
self.table.setRowCount(len(seasons))
for row, season in enumerate(seasons):
self.table.setItem(row, 0, QTableWidgetItem(str(season)))
self.save_button.setEnabled(True)
else:
QMessageBox.warning(self, "Veri Yok", "Hiçbir sezon bilgisi bulunamadı.")
def save_to_file(self):
"""
Tablo verilerini dosyaya kaydet.
"""
file_path, _ = QFileDialog.getSaveFileName(self, "Dosya Kaydet", "", "Text Files (*.txt)")
if file_path:
try:
with open(file_path, "w", encoding="utf-8") as file:
for row in range(self.table.rowCount()):
season = self.table.item(row, 0).text()
file.write(f"{season}\n")
QMessageBox.information(self, "Başarılı", "Dosya başarıyla kaydedildi.")
except Exception as e:
QMessageBox.critical(self, "Hata", f"Dosya kaydedilirken bir hata oluştu: {e}")
# Uygulamayı çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
ex = SeasonApp()
ex.show()
sys.exit(app.exec_())

--------------------------------------------------------------------------------
Lig sorgulaması nasıl yapılır
API Kullanım Kılavuzunu Analiz Ettim: İşte Özet ve Öneriler
1. API'nin Temel Amacı
Bu API, ligleri ve kupaları listelemek için kullanılmaktadır. Öne çıkan noktalar:
●
Lig ID'leri benzersizdir ve tüm sezonlar boyunca korunur.
●
Lig logolarına erişim için bir URL yapılandırması sağlanır.
●
Format: https://media.api-sports.io/football/leagues/{league_id}.png
2. Dönen Veri: Coverage Bilgisi
API, her lig için veri kapsamını (coverage) döner. Örneğin:
"coverage": {
"fixtures": {
"events": true,
"lineups": true,
"statistics_fixtures": false,
"statistics_players": false
},
"standings": true,
"players": true,
"top_scorers": true,
"top_assists": true,
"top_cards": true,
"injuries": true,
"predictions": true,
"odds": false
}
●
True olan değerler, o özelliğin mevcut olduğunu gösterir.
●
Bazı özellikler, örneğin statistics_fixtures, odds, başlangıçta False olabilir. Bu, sezon başlamadan önce normal bir durumdur.
●
Kapsamlı analizler yaparken bu veriler kontrol edilmelidir.
3. Sorgu Parametreleri (Kullanılabilir Filtreler)
API, aşağıdaki parametrelerle esnek sorgular yapılmasına olanak tanır:
Parametre Tip Açıklama id integer Lig ID'si (tek bir lig için sorgu). name string Lig ismi ile arama yapılabilir. country string Ülke adı ile filtreleme. code string Ülkenin alpha kodu (ör: GB, FR). season integer Sezon yılı (YYYY formatında). team integer Bir takım ID'sine ait ligler. type string Lig tipi: "league" veya "cup". current string Aktif sezonları listeleme: "true". search string Lig veya ülke ismi (min 3 karakter). last integer Son X lig/kupa eklemesini getirir. Not: Parametrelerin birleştirilerek kullanılması mümkündür.
4. Response (Yanıt) Durum Kodları
Durum Kodu Açıklama 200 OK Sorgu başarıyla tamamlandı. 204 No Content İçerik bulunamadı. 499 Timeout İstek zaman aşımına uğradı. 500 Server Error Sunucu tarafında bir hata oluştu. 5. Önerilen Kullanım Senaryoları (Use Cases)
●
Aktif Sezonları Getirme
●
Parametre: current=true
●
Amaç: Sadece aktif sezonları listelemek.
●
Belirli Bir Ülke için Ligleri Getirme
●
Parametre: country=England
●
Son Eklenen Ligleri Listeleme
●
Parametre: last=5
●
Amaç: Yeni eklenen ligleri hızlıca tespit etmek.
●
Belirli Bir Ligin Bilgilerini Getirme
●
Parametre: id=39
6. Önemli Noktalar ve Veri Yönetimi
●
Veri Güncellenme Sıklığı:
●
API, günde birkaç kez güncellenmektedir. Bu nedenle aşırı sorgu yükünü önlemek adına saatte 1 sorgu önerilir.
●
Benzersizlik:
●
Lig ID'leri benzersizdir ve tüm sezonlar için geçerlidir.
●
Aynı isimdeki farklı ligler (örn. "Premier League") için ülke kodu ve ID kullanılmalıdır.
●
Kapsam Kontrolü:
●
Coverage verisi sezon başlamadan önce false olabilir, bu normaldir.
Geliştirme İçin Öneri (Yapacağımız Adımlar)
1.
Tüm Ligleri Getir: get_leagues() fonksiyonunu kullanarak tüm lig ve ID bilgilerini çekeceğiz.
2.
Aktif Sezonları Filtrele: current=true parametresi ile sadece aktif ligleri listeleyeceğiz.
3.
Benzersiz Ligleri Tanımla: Lig adını ülke bilgisi ile birleştirerek benzersiz hale getireceğiz.
4.
Hataları Yönet: 204, 499 ve 500 durum kodlarına uygun hata mesajları ve çözümler ekleyeceğiz.
5.
Kapsam Bilgisini Dahil Et: Her ligin coverage detaylarını isteğe bağlı olarak ekleyebiliriz.
Bu adımlarla sağlam bir algoritma oluşturup API kullanımını en verimli şekilde planlayabiliriz. Geliştirme önerilerime başlamak ister misiniz?
kod örneği :"import requests
import json
from PyQt5.QtWidgets import (
QApplication, QWidget, QVBoxLayout, QPushButton, QTableWidget,
QTableWidgetItem, QHBoxLayout, QMessageBox
)
import sys
# API Ayarı ve Bağlantı
API_KEY = "9c8a801a48c3b5fe84588a81ef607e58" # API Anahtarınız
BASE_URL = "https://v3.football.api-sports.io/"
HEADERS = {"x-apisports-key": API_KEY}
# API'den veri çekme fonksiyonu
def fetch_data(endpoint, params=None):
"""
API'den belirtilen endpoint'e ve parametrelere göre veri çekme fonksiyonu.
"""
url = f"{BASE_URL}{endpoint}"
try:
response = requests.get(url, headers=HEADERS, params=params)
if response.status_code == 204:
return {"error": "204 - İçerik bulunamadı."}
elif response.status_code == 499:
return {"error": "499 - Zaman aşımı hatası, lütfen tekrar deneyin."}
elif response.status_code == 500:
return {"error": "500 - Sunucu hatası, lütfen daha sonra tekrar deneyin."}
response.raise_for_status()
return response.json()
except requests.exceptions.RequestException as e:
return {"error": str(e)}
# Aktif Ligleri Listeleme
def get_active_leagues():
"""
API'den sadece aktif ligleri listeleyen fonksiyon.
Varsayılan olarak kapsam bilgilerini de içerir.
"""
params = {"current": "true"} # Sadece aktif ligleri getir
data = fetch_data("leagues", params)
if "error" in data:
return f"API Hatası: {data['error']}", []
response_data = data.get("response", [])
unique_leagues = [] # Benzersiz ligleri tutacak liste
for league in response_data:
league_id = league.get('league', {}).get('id', 'Bilinmiyor')
league_name = league.get('league', {}).get('name', 'Bilinmiyor')
country_name = league.get('country', {}).get('name', 'Bilinmiyor')
coverage = league.get('seasons', [{}])[0].get('coverage', {})
fixtures = coverage.get('fixtures', {})
unique_leagues.append([
league_id, league_name, country_name,
fixtures.get('events', False),
fixtures.get('lineups', False),
fixtures.get('statistics_fixtures', False),
coverage.get('predictions', False)
])
return None, unique_leagues
# Ana Uygulama Sınıfı
class LeagueApp(QWidget):
def __init__(self):
super().__init__()
self.initUI()
def initUI(self):
"""
Arayüz bileşenlerini oluşturma ve düzenleme.
"""
self.setWindowTitle("Aktif Lig Bilgileri")
self.setGeometry(0, 0, 1200, 800) # Pencere başlangıç boyutu
self.showMaximized() # Tam ekran modunda aç
self.layout = QVBoxLayout()
# Ligleri Getir Butonu
self.fetch_button = QPushButton("Aktif Ligleri Al")
self.fetch_button.clicked.connect(self.fetch_leagues)
self.layout.addWidget(self.fetch_button)
# Tablo
self.table = QTableWidget()
self.layout.addWidget(self.table)
# Kapat Butonu
self.close_button = QPushButton("Kapat")
self.close_button.clicked.connect(self.close_app)
self.layout.addWidget(self.close_button)
self.setLayout(self.layout)
def fetch_leagues(self):
"""
API'den aktif lig bilgilerini çek ve tabloya yazdır.
"""
self.table.clear()
self.fetch_button.setText("Lig bilgileri alınıyor...")
self.fetch_button.setEnabled(False)
error, leagues = get_active_leagues()
if error:
QMessageBox.warning(self, "Hata", error)
self.fetch_button.setText("Aktif Ligleri Al")
self.fetch_button.setEnabled(True)
return
# Tablo başlıklarını ayarla
self.table.setColumnCount(7)
self.table.setHorizontalHeaderLabels([
"Lig ID", "Lig Adı", "Ülke", "Olaylar", "Kadrolar",
"İstatistikler", "Tahminler"
])
# Verileri tabloya ekle
self.table.setRowCount(len(leagues))
for row, league in enumerate(leagues):
for col, value in enumerate(league):
self.table.setItem(row, col, QTableWidgetItem(str(value)))
self.fetch_button.setText("Aktif Ligleri Al")
self.fetch_button.setEnabled(True)
def close_app(self):
"""
Uygulamayı kapatma işlemi.
"""
self.close()
# Uygulamayı çalıştırma
if __name__ == "__main__":
app = QApplication(sys.argv)
ex = LeagueApp()
ex.show()
sys.exit(app.exec_())
"